{"version":3,"sources":["webpack:///wsclient-evented.js","webpack:///webpack/bootstrap 6777fdbb7d0ff2b1739f","webpack:///./lib/index.js","webpack:///./~/fbjs/lib/invariant.js","webpack:///./~/fbemitter/index.js","webpack:///./~/fbemitter/lib/BaseEventEmitter.js","webpack:///./~/fbemitter/lib/EmitterSubscription.js","webpack:///./~/fbemitter/lib/EventSubscription.js","webpack:///./~/fbemitter/lib/EventSubscriptionVendor.js","webpack:///./~/fbjs/lib/emptyFunction.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_fbemitter","WsClientEvented","url","_this","this","protocols","arguments","undefined","options","emitter","EventEmitter","reconnectAttempts","timeout","forcedClose","ws","settings","autoOpen","autoReconnect","reconnectInterval","binaryType","maxReconnects","onBeforeWsOpen","onWsOpen","onWsMessage","onWsClose","onWsError","_arr","_loop","e","_i","addListener","evt","data","JSON","parse","responseType","type","emit","open","callback","removeAllListeners","payload","send","stringify","_this2","reconnecting","close","WebSocket","addEventListener","setTimeout","code","reason","invariant","condition","format","a","b","d","f","error","Error","args","argIndex","replace","framesToPop","fbemitter","EmitterSubscription","EventSubscriptionVendor","emptyFunction","BaseEventEmitter","_subscriber","_currentSubscription","eventType","listener","context","addSubscription","once","removeCurrentListener","apply","removeAllSubscriptions","removeSubscription","listeners","subscriptions","getSubscriptionsForType","filter","thatReturnsTrue","map","subscription","keys","ii","__emitToSubscription","concat","Array","slice","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","EventSubscription","_EventSubscription","subscriber","remove","_subscriptionsForType","push","subscriptionsForType","makeEmptyFunction","arg","thatReturns","thatReturnsFalse","thatReturnsNull","thatReturnsThis","thatReturnsArgument"],"mappings":"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","file":"wsclient-evented.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _fbemitter = __webpack_require__(2);\n\t\n\tvar WsClientEvented = (function () {\n\t\n\t  /**\n\t   * Create a new instance of WsClientEvent\n\t   * @param {String} url Url to connect to\n\t   * @param {String|Array} protocols List of protocols [optional]\n\t   * @param {Object} options Options to pass in [optional]\n\t   */\n\t\n\t  function WsClientEvented(url) {\n\t    var _this = this;\n\t\n\t    var protocols = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\t    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t    _classCallCheck(this, WsClientEvented);\n\t\n\t    // Instanciate a new event emitter\n\t    this.emitter = new _fbemitter.EventEmitter();\n\t\n\t    this.url = url;\n\t    this.protocols = protocols.length > 0 ? protocols : '';\n\t\n\t    // How often did the websocket retry to connect?\n\t    this.reconnectAttempts = 0;\n\t\n\t    // The current timeout\n\t    this.timeout = null;\n\t\n\t    // Set to true to indicate no reconnect should take place\n\t    this.forcedClose = false;\n\t\n\t    // The websocket instance\n\t    this.ws = null;\n\t\n\t    // Default settings\n\t    this.settings = {\n\t      autoOpen: true,\n\t      autoReconnect: true,\n\t      reconnectInterval: 250,\n\t      binaryType: 'blob',\n\t      maxReconnects: null,\n\t      onBeforeWsOpen: null,\n\t      onWsOpen: null,\n\t      onWsMessage: null,\n\t      onWsClose: null,\n\t      onWsError: null\n\t    };\n\t\n\t    // Merge settings with defaults\n\t    for (var key in options) {\n\t      this.settings[key] = options[key];\n\t    }\n\t\n\t    // Attach all active listeners\n\t    var _arr = ['onBeforeWsOpen', 'onWsOpen', 'onWsMessage', 'onWsClose', 'onWsError'];\n\t\n\t    var _loop = function () {\n\t      var e = _arr[_i];\n\t      if (typeof _this.settings[e] === 'function') {\n\t        _this.emitter.addListener(e, function (evt) {\n\t          _this.settings[e](evt, _this);\n\t        });\n\t      }\n\t    };\n\t\n\t    for (var _i = 0; _i < _arr.length; _i++) {\n\t      _loop();\n\t    }\n\t\n\t    // Handle websocket requests that come back in the required format.\n\t    // @todo: Add support for binary\n\t    this.emitter.addListener('onWsMessage', function (e) {\n\t      var data = JSON.parse(e.data);\n\t      var responseType = typeof data;\n\t\n\t      if (responseType === 'object' && data.type) {\n\t        _this.emitter.emit(data.type, e, data);\n\t      }\n\t    });\n\t\n\t    if (this.settings.autoOpen) {\n\t      this.open();\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Add a new event listener\n\t   * @param {String} evt Name of the event\n\t   * @param {Function} callback Function to attach\n\t   * @return {WsClientEvented}\n\t   */\n\t\n\t  _createClass(WsClientEvented, [{\n\t    key: 'addListener',\n\t    value: function addListener(evt, callback) {\n\t      this.emitter.addListener(evt, callback);\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Removes all listeners with a given name\n\t     * @param  {String} evt\n\t     * @return {WsClientEvented}\n\t     */\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(evt) {\n\t      this.emitter.removeAllListeners(evt);\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Send a new request\n\t     * @param  {String} event Event to send\n\t     * @param  {Object|String} payload Data to send as payload\n\t     * @return {WsClientEvent}\n\t     */\n\t  }, {\n\t    key: 'send',\n\t    value: function send(type, payload) {\n\t\n\t      // Skip if type or payload are not given\n\t      if (!type || !payload) {\n\t        throw 'Must provide type and payload, provided: ' + type + ', ' + payload;\n\t      }\n\t\n\t      // Only send if the connection is available!\n\t      if (!this.ws) {\n\t        return this;\n\t      }\n\t\n\t      this.ws.send(JSON.stringify({\n\t        type: type,\n\t        payload: payload\n\t      }));\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Open the websocket\n\t     * @param {Boolean} reconnecting Status of the connection (true if a forced reconnect was done)\n\t     * @return {WsClientEvent}\n\t     */\n\t  }, {\n\t    key: 'open',\n\t    value: function open() {\n\t      var _this2 = this;\n\t\n\t      var reconnecting = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\t\n\t      // If the maximal amounts of reconnects is hit, just exit\n\t      if (this.settings.maxReconnects && this.reconnectAttempts >= this.settings.maxReconnects) {\n\t        return this;\n\t      }\n\t\n\t      // Close the websocket if it is already open\n\t      if (!reconnecting && this.ws) {\n\t        this.close();\n\t      }\n\t\n\t      this.emitter.emit('onBeforeWsOpen');\n\t\n\t      // Create the new websocket instance\n\t      this.ws = new WebSocket(this.url, this.protocols);\n\t      this.ws.binaryType = this.settings.binaryType;\n\t\n\t      // Add the needed events\n\t      this.ws.addEventListener('open', function (e) {\n\t        _this2.emitter.emit('onWsOpen', e, _this2);\n\t\n\t        // We are connected, so reset the reconnect attempts\n\t        _this2.reconnectAttempts = 0;\n\t      });\n\t\n\t      this.ws.addEventListener('message', function (e) {\n\t        _this2.emitter.emit('onWsMessage', e, _this2);\n\t      });\n\t\n\t      this.ws.addEventListener('close', function (e) {\n\t        _this2.emitter.emit('onWsClose', e, _this2);\n\t\n\t        // Reconnect the websocket automatically if it should\n\t        if (!_this2.forcedClose && _this2.settings.autoReconnect) {\n\t          setTimeout(function () {\n\t            _this2.reconnectAttempts++;\n\t            _this2.open(true);\n\t          }, 50);\n\t        }\n\t      });\n\t\n\t      this.ws.addEventListener('error', function (e) {\n\t        _this2.emitter.emit('onWsError', e, _this2);\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Close the websocket if it is open\n\t     * @param  {Number} code The code to send [optional]\n\t     * @param  {String} reason The reason for closing [optional]\n\t     * @return {WsClientEvent}\n\t     */\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      var code = arguments.length <= 0 || arguments[0] === undefined ? 1000 : arguments[0];\n\t      var reason = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\t\n\t      if (this.ws) {\n\t        this.forcedClose = true;\n\t        this.ws.close(code, reason);\n\t        this.ws = null;\n\t      }\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return WsClientEvented;\n\t})();\n\t\n\texports['default'] = WsClientEvented;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2013-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @providesModule invariant\n\t */\n\t\n\t\"use strict\";\n\t\n\t/**\n\t * Use invariant() to assert state which your program assumes to be true.\n\t *\n\t * Provide sprintf-style format (only %s is supported) and arguments\n\t * to provide information about what broke and what you were\n\t * expecting.\n\t *\n\t * The invariant message will be stripped in production, but the invariant\n\t * will remain to ensure logic does not differ in production.\n\t */\n\t\n\tvar invariant = function (condition, format, a, b, c, d, e, f) {\n\t  if (false) {\n\t    if (format === undefined) {\n\t      throw new Error('invariant requires an error message argument');\n\t    }\n\t  }\n\t\n\t  if (!condition) {\n\t    var error;\n\t    if (format === undefined) {\n\t      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n\t    } else {\n\t      var args = [a, b, c, d, e, f];\n\t      var argIndex = 0;\n\t      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {\n\t        return args[argIndex++];\n\t      }));\n\t    }\n\t\n\t    error.framesToPop = 1; // we don't care about invariant's own frame\n\t    throw error;\n\t  }\n\t};\n\t\n\tmodule.exports = invariant;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\tvar fbemitter = {\n\t  EventEmitter: __webpack_require__(3)\n\t};\n\t\n\tmodule.exports = fbemitter;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @providesModule BaseEventEmitter\n\t * @typechecks\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar EmitterSubscription = __webpack_require__(4);\n\tvar EventSubscriptionVendor = __webpack_require__(6);\n\t\n\tvar emptyFunction = __webpack_require__(7);\n\tvar invariant = __webpack_require__(1);\n\t\n\t/**\n\t * @class BaseEventEmitter\n\t * @description\n\t * An EventEmitter is responsible for managing a set of listeners and publishing\n\t * events to them when it is told that such events happened. In addition to the\n\t * data for the given event it also sends a event control object which allows\n\t * the listeners/handlers to prevent the default behavior of the given event.\n\t *\n\t * The emitter is designed to be generic enough to support all the different\n\t * contexts in which one might want to emit events. It is a simple multicast\n\t * mechanism on top of which extra functionality can be composed. For example, a\n\t * more advanced emitter may use an EventHolder and EventFactory.\n\t */\n\t\n\tvar BaseEventEmitter = (function () {\n\t  /**\n\t   * @constructor\n\t   */\n\t\n\t  function BaseEventEmitter() {\n\t    _classCallCheck(this, BaseEventEmitter);\n\t\n\t    this._subscriber = new EventSubscriptionVendor();\n\t    this._currentSubscription = null;\n\t  }\n\t\n\t  /**\n\t   * Adds a listener to be invoked when events of the specified type are\n\t   * emitted. An optional calling context may be provided. The data arguments\n\t   * emitted will be passed to the listener function.\n\t   *\n\t   * TODO: Annotate the listener arg's type. This is tricky because listeners\n\t   *       can be invoked with varargs.\n\t   *\n\t   * @param {string} eventType - Name of the event to listen to\n\t   * @param {function} listener - Function to invoke when the specified event is\n\t   *   emitted\n\t   * @param {*} context - Optional context object to use when invoking the\n\t   *   listener\n\t   */\n\t\n\t  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\n\t    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n\t  };\n\t\n\t  /**\n\t   * Similar to addListener, except that the listener is removed after it is\n\t   * invoked once.\n\t   *\n\t   * @param {string} eventType - Name of the event to listen to\n\t   * @param {function} listener - Function to invoke only once when the\n\t   *   specified event is emitted\n\t   * @param {*} context - Optional context object to use when invoking the\n\t   *   listener\n\t   */\n\t\n\t  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\n\t    var emitter = this;\n\t    return this.addListener(eventType, function () {\n\t      emitter.removeCurrentListener();\n\t      listener.apply(context, arguments);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Removes all of the registered listeners, including those registered as\n\t   * listener maps.\n\t   *\n\t   * @param {?string} eventType - Optional name of the event whose registered\n\t   *   listeners to remove\n\t   */\n\t\n\t  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\n\t    this._subscriber.removeAllSubscriptions(eventType);\n\t  };\n\t\n\t  /**\n\t   * Provides an API that can be called during an eventing cycle to remove the\n\t   * last listener that was invoked. This allows a developer to provide an event\n\t   * object that can remove the listener (or listener map) during the\n\t   * invocation.\n\t   *\n\t   * If it is called when not inside of an emitting cycle it will throw.\n\t   *\n\t   * @throws {Error} When called not during an eventing cycle\n\t   *\n\t   * @example\n\t   *   var subscription = emitter.addListenerMap({\n\t   *     someEvent: function(data, event) {\n\t   *       console.log(data);\n\t   *       emitter.removeCurrentListener();\n\t   *     }\n\t   *   });\n\t   *\n\t   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n\t   *   emitter.emit('someEvent', 'def'); // does not log anything\n\t   */\n\t\n\t  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\n\t    !!!this._currentSubscription ?  false ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\n\t    this._subscriber.removeSubscription(this._currentSubscription);\n\t  };\n\t\n\t  /**\n\t   * Returns an array of listeners that are currently registered for the given\n\t   * event.\n\t   *\n\t   * @param {string} eventType - Name of the event to query\n\t   * @return {array}\n\t   */\n\t\n\t  BaseEventEmitter.prototype.listeners = function listeners(eventType) /* TODO: Array<EventSubscription> */{\n\t    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n\t    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n\t      return subscription.listener;\n\t    }) : [];\n\t  };\n\t\n\t  /**\n\t   * Emits an event of the given type with the given data. All handlers of that\n\t   * particular type will be notified.\n\t   *\n\t   * @param {string} eventType - Name of the event to emit\n\t   * @param {*} Arbitrary arguments to be passed to each registered listener\n\t   *\n\t   * @example\n\t   *   emitter.addListener('someEvent', function(message) {\n\t   *     console.log(message);\n\t   *   });\n\t   *\n\t   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n\t   */\n\t\n\t  BaseEventEmitter.prototype.emit = function emit(eventType) {\n\t    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n\t    if (subscriptions) {\n\t      var keys = Object.keys(subscriptions);\n\t      for (var ii = 0; ii < keys.length; ii++) {\n\t        var key = keys[ii];\n\t        var subscription = subscriptions[key];\n\t        // The subscription may have been removed during this event loop.\n\t        if (subscription) {\n\t          this._currentSubscription = subscription;\n\t          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n\t        }\n\t      }\n\t      this._currentSubscription = null;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Provides a hook to override how the emitter emits an event to a specific\n\t   * subscription. This allows you to set up logging and error boundaries\n\t   * specific to your environment.\n\t   *\n\t   * @param {EmitterSubscription} subscription\n\t   * @param {string} eventType\n\t   * @param {*} Arbitrary arguments to be passed to each registered listener\n\t   */\n\t\n\t  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n\t    var args = Array.prototype.slice.call(arguments, 2);\n\t    subscription.listener.apply(subscription.context, args);\n\t  };\n\t\n\t  return BaseEventEmitter;\n\t})();\n\t\n\tmodule.exports = BaseEventEmitter;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t * \n\t * @providesModule EmitterSubscription\n\t * @typechecks\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar EventSubscription = __webpack_require__(5);\n\t\n\t/**\n\t * EmitterSubscription represents a subscription with listener and context data.\n\t */\n\t\n\tvar EmitterSubscription = (function (_EventSubscription) {\n\t  _inherits(EmitterSubscription, _EventSubscription);\n\t\n\t  /**\n\t   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls\n\t   *   this subscription\n\t   * @param {function} listener - Function to invoke when the specified event is\n\t   *   emitted\n\t   * @param {*} context - Optional context object to use when invoking the\n\t   *   listener\n\t   */\n\t\n\t  function EmitterSubscription(subscriber, listener, context) {\n\t    _classCallCheck(this, EmitterSubscription);\n\t\n\t    _EventSubscription.call(this, subscriber);\n\t    this.listener = listener;\n\t    this.context = context;\n\t  }\n\t\n\t  return EmitterSubscription;\n\t})(EventSubscription);\n\t\n\tmodule.exports = EmitterSubscription;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t * \n\t * @providesModule EventSubscription\n\t * @typechecks\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * EventSubscription represents a subscription to a particular event. It can\n\t * remove its own subscription.\n\t */\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar EventSubscription = (function () {\n\t\n\t  /**\n\t   * @param {EventSubscriptionVendor} subscriber the subscriber that controls\n\t   *   this subscription.\n\t   */\n\t\n\t  function EventSubscription(subscriber) {\n\t    _classCallCheck(this, EventSubscription);\n\t\n\t    this.subscriber = subscriber;\n\t  }\n\t\n\t  /**\n\t   * Removes this subscription from the subscriber that controls it.\n\t   */\n\t\n\t  EventSubscription.prototype.remove = function remove() {\n\t    this.subscriber.removeSubscription(this);\n\t  };\n\t\n\t  return EventSubscription;\n\t})();\n\t\n\tmodule.exports = EventSubscription;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t * \n\t * @providesModule EventSubscriptionVendor\n\t * @typechecks\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar invariant = __webpack_require__(1);\n\t\n\t/**\n\t * EventSubscriptionVendor stores a set of EventSubscriptions that are\n\t * subscribed to a particular event type.\n\t */\n\t\n\tvar EventSubscriptionVendor = (function () {\n\t  function EventSubscriptionVendor() {\n\t    _classCallCheck(this, EventSubscriptionVendor);\n\t\n\t    this._subscriptionsForType = {};\n\t    this._currentSubscription = null;\n\t  }\n\t\n\t  /**\n\t   * Adds a subscription keyed by an event type.\n\t   *\n\t   * @param {string} eventType\n\t   * @param {EventSubscription} subscription\n\t   */\n\t\n\t  EventSubscriptionVendor.prototype.addSubscription = function addSubscription(eventType, subscription) {\n\t    !(subscription.subscriber === this) ?  false ? invariant(false, 'The subscriber of the subscription is incorrectly set.') : invariant(false) : undefined;\n\t    if (!this._subscriptionsForType[eventType]) {\n\t      this._subscriptionsForType[eventType] = [];\n\t    }\n\t    var key = this._subscriptionsForType[eventType].length;\n\t    this._subscriptionsForType[eventType].push(subscription);\n\t    subscription.eventType = eventType;\n\t    subscription.key = key;\n\t    return subscription;\n\t  };\n\t\n\t  /**\n\t   * Removes a bulk set of the subscriptions.\n\t   *\n\t   * @param {?string} eventType - Optional name of the event type whose\n\t   *   registered supscriptions to remove, if null remove all subscriptions.\n\t   */\n\t\n\t  EventSubscriptionVendor.prototype.removeAllSubscriptions = function removeAllSubscriptions(eventType) {\n\t    if (eventType === undefined) {\n\t      this._subscriptionsForType = {};\n\t    } else {\n\t      delete this._subscriptionsForType[eventType];\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Removes a specific subscription. Instead of calling this function, call\n\t   * `subscription.remove()` directly.\n\t   *\n\t   * @param {object} subscription\n\t   */\n\t\n\t  EventSubscriptionVendor.prototype.removeSubscription = function removeSubscription(subscription) {\n\t    var eventType = subscription.eventType;\n\t    var key = subscription.key;\n\t\n\t    var subscriptionsForType = this._subscriptionsForType[eventType];\n\t    if (subscriptionsForType) {\n\t      delete subscriptionsForType[key];\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Returns the array of subscriptions that are currently registered for the\n\t   * given event type.\n\t   *\n\t   * Note: This array can be potentially sparse as subscriptions are deleted\n\t   * from it when they are removed.\n\t   *\n\t   * TODO: This returns a nullable array. wat?\n\t   *\n\t   * @param {string} eventType\n\t   * @return {?array}\n\t   */\n\t\n\t  EventSubscriptionVendor.prototype.getSubscriptionsForType = function getSubscriptionsForType(eventType) {\n\t    return this._subscriptionsForType[eventType];\n\t  };\n\t\n\t  return EventSubscriptionVendor;\n\t})();\n\t\n\tmodule.exports = EventSubscriptionVendor;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright 2013-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @providesModule emptyFunction\n\t */\n\t\n\t\"use strict\";\n\t\n\tfunction makeEmptyFunction(arg) {\n\t  return function () {\n\t    return arg;\n\t  };\n\t}\n\t\n\t/**\n\t * This function accepts and discards inputs; it has no side effects. This is\n\t * primarily useful idiomatically for overridable function endpoints which\n\t * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n\t */\n\tfunction emptyFunction() {}\n\t\n\temptyFunction.thatReturns = makeEmptyFunction;\n\temptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n\temptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n\temptyFunction.thatReturnsNull = makeEmptyFunction(null);\n\temptyFunction.thatReturnsThis = function () {\n\t  return this;\n\t};\n\temptyFunction.thatReturnsArgument = function (arg) {\n\t  return arg;\n\t};\n\t\n\tmodule.exports = emptyFunction;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** wsclient-evented.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6777fdbb7d0ff2b1739f\n **/","import { EventEmitter } from 'fbemitter';\n\nclass WsClientEvented {\n\n  /**\n   * Create a new instance of WsClientEvent\n   * @param {String} url Url to connect to\n   * @param {String|Array} protocols List of protocols [optional]\n   * @param {Object} options Options to pass in [optional]\n   */\n  constructor(url, protocols='', options={}) {\n\n    // Instanciate a new event emitter\n    this.emitter = new EventEmitter();\n\n    this.url = url;\n    this.protocols = protocols.length > 0 ? protocols : '';\n\n    // How often did the websocket retry to connect?\n    this.reconnectAttempts = 0;\n\n    // The current timeout\n    this.timeout = null;\n\n    // Set to true to indicate no reconnect should take place\n    this.forcedClose = false;\n\n    // The websocket instance\n    this.ws = null;\n\n    // Default settings\n    this.settings = {\n      autoOpen: true,\n      autoReconnect: true,\n      reconnectInterval: 250,\n      binaryType: 'blob',\n      maxReconnects: null,\n      onBeforeWsOpen: null,\n      onWsOpen: null,\n      onWsMessage: null,\n      onWsClose: null,\n      onWsError: null\n    };\n\n    // Merge settings with defaults\n    for(let key in options) {\n      this.settings[key] = options[key];\n    }\n\n    // Attach all active listeners\n    for(let e of [ 'onBeforeWsOpen', 'onWsOpen', 'onWsMessage', 'onWsClose', 'onWsError' ]) {\n      if(typeof this.settings[e] === 'function') {\n        this.emitter.addListener(e, (evt) => {\n          this.settings[e](evt, this);\n        });\n      }\n    }\n\n    // Handle websocket requests that come back in the required format.\n    // @todo: Add support for binary\n    this.emitter.addListener('onWsMessage', (e) => {\n      let data = JSON.parse(e.data);\n      let responseType = typeof data;\n\n      if(responseType === 'object' && data.type) {\n        this.emitter.emit(data.type, e, data);\n      }\n    });\n\n    if(this.settings.autoOpen) {\n      this.open();\n    }\n  }\n\n  /**\n   * Add a new event listener\n   * @param {String} evt Name of the event\n   * @param {Function} callback Function to attach\n   * @return {WsClientEvented}\n   */\n  addListener(evt, callback) {\n    this.emitter.addListener(evt, callback);\n    return this;\n  }\n\n  /**\n   * Removes all listeners with a given name\n   * @param  {String} evt\n   * @return {WsClientEvented}\n   */\n  removeListener(evt) {\n    this.emitter.removeAllListeners(evt);\n    return this;\n  }\n\n  /**\n   * Send a new request\n   * @param  {String} event Event to send\n   * @param  {Object|String} payload Data to send as payload\n   * @return {WsClientEvent}\n   */\n  send(type, payload) {\n\n    // Skip if type or payload are not given\n    if(!type || !payload) {\n      throw `Must provide type and payload, provided: ${type}, ${payload}`;\n    }\n\n    // Only send if the connection is available!\n    if(!this.ws) {\n      return this;\n    }\n\n    this.ws.send(JSON.stringify({\n      type: type,\n      payload: payload\n    }));\n\n    return this;\n  }\n\n  /**\n   * Open the websocket\n   * @param {Boolean} reconnecting Status of the connection (true if a forced reconnect was done)\n   * @return {WsClientEvent}\n   */\n  open(reconnecting=false) {\n\n    // If the maximal amounts of reconnects is hit, just exit\n    if(this.settings.maxReconnects && this.reconnectAttempts >= this.settings.maxReconnects) {\n      return this;\n    }\n\n    // Close the websocket if it is already open\n    if(!reconnecting && this.ws) {\n      this.close();\n    }\n\n    this.emitter.emit('onBeforeWsOpen');\n\n    // Create the new websocket instance\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.binaryType = this.settings.binaryType;\n\n    // Add the needed events\n    this.ws.addEventListener('open', (e) => {\n      this.emitter.emit('onWsOpen', e, this);\n\n      // We are connected, so reset the reconnect attempts\n      this.reconnectAttempts = 0;\n    });\n\n    this.ws.addEventListener('message', (e) => {\n      this.emitter.emit('onWsMessage', e, this);\n    });\n\n    this.ws.addEventListener('close', (e) => {\n      this.emitter.emit('onWsClose', e, this);\n\n      // Reconnect the websocket automatically if it should\n      if(!this.forcedClose && this.settings.autoReconnect) {\n        setTimeout(() => {\n          this.reconnectAttempts++;\n          this.open(true);\n        }, 50);\n      }\n    });\n\n    this.ws.addEventListener('error', (e) => {\n      this.emitter.emit('onWsError', e, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * Close the websocket if it is open\n   * @param  {Number} code The code to send [optional]\n   * @param  {String} reason The reason for closing [optional]\n   * @return {WsClientEvent}\n   */\n  close(code=1000, reason='') {\n    if(this.ws) {\n      this.forcedClose = true;\n      this.ws.close(code, reason);\n      this.ws = null;\n    }\n    return this;\n  }\n}\n\nexport default WsClientEvented;\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/index.js\n **/","/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule invariant\n */\n\n\"use strict\";\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function (condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/invariant.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar fbemitter = {\n  EventEmitter: require('./lib/BaseEventEmitter')\n};\n\nmodule.exports = fbemitter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/index.js\n ** module id = 2\n ** module chunks = 0\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BaseEventEmitter\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar EmitterSubscription = require('./EmitterSubscription');\nvar EventSubscriptionVendor = require('./EventSubscriptionVendor');\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * @class BaseEventEmitter\n * @description\n * An EventEmitter is responsible for managing a set of listeners and publishing\n * events to them when it is told that such events happened. In addition to the\n * data for the given event it also sends a event control object which allows\n * the listeners/handlers to prevent the default behavior of the given event.\n *\n * The emitter is designed to be generic enough to support all the different\n * contexts in which one might want to emit events. It is a simple multicast\n * mechanism on top of which extra functionality can be composed. For example, a\n * more advanced emitter may use an EventHolder and EventFactory.\n */\n\nvar BaseEventEmitter = (function () {\n  /**\n   * @constructor\n   */\n\n  function BaseEventEmitter() {\n    _classCallCheck(this, BaseEventEmitter);\n\n    this._subscriber = new EventSubscriptionVendor();\n    this._currentSubscription = null;\n  }\n\n  /**\n   * Adds a listener to be invoked when events of the specified type are\n   * emitted. An optional calling context may be provided. The data arguments\n   * emitted will be passed to the listener function.\n   *\n   * TODO: Annotate the listener arg's type. This is tricky because listeners\n   *       can be invoked with varargs.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\n    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n  };\n\n  /**\n   * Similar to addListener, except that the listener is removed after it is\n   * invoked once.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke only once when the\n   *   specified event is emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\n    var emitter = this;\n    return this.addListener(eventType, function () {\n      emitter.removeCurrentListener();\n      listener.apply(context, arguments);\n    });\n  };\n\n  /**\n   * Removes all of the registered listeners, including those registered as\n   * listener maps.\n   *\n   * @param {?string} eventType - Optional name of the event whose registered\n   *   listeners to remove\n   */\n\n  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\n    this._subscriber.removeAllSubscriptions(eventType);\n  };\n\n  /**\n   * Provides an API that can be called during an eventing cycle to remove the\n   * last listener that was invoked. This allows a developer to provide an event\n   * object that can remove the listener (or listener map) during the\n   * invocation.\n   *\n   * If it is called when not inside of an emitting cycle it will throw.\n   *\n   * @throws {Error} When called not during an eventing cycle\n   *\n   * @example\n   *   var subscription = emitter.addListenerMap({\n   *     someEvent: function(data, event) {\n   *       console.log(data);\n   *       emitter.removeCurrentListener();\n   *     }\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   *   emitter.emit('someEvent', 'def'); // does not log anything\n   */\n\n  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\n    !!!this._currentSubscription ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\n    this._subscriber.removeSubscription(this._currentSubscription);\n  };\n\n  /**\n   * Returns an array of listeners that are currently registered for the given\n   * event.\n   *\n   * @param {string} eventType - Name of the event to query\n   * @return {array}\n   */\n\n  BaseEventEmitter.prototype.listeners = function listeners(eventType) /* TODO: Array<EventSubscription> */{\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n      return subscription.listener;\n    }) : [];\n  };\n\n  /**\n   * Emits an event of the given type with the given data. All handlers of that\n   * particular type will be notified.\n   *\n   * @param {string} eventType - Name of the event to emit\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   *\n   * @example\n   *   emitter.addListener('someEvent', function(message) {\n   *     console.log(message);\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   */\n\n  BaseEventEmitter.prototype.emit = function emit(eventType) {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    if (subscriptions) {\n      var keys = Object.keys(subscriptions);\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        var subscription = subscriptions[key];\n        // The subscription may have been removed during this event loop.\n        if (subscription) {\n          this._currentSubscription = subscription;\n          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n        }\n      }\n      this._currentSubscription = null;\n    }\n  };\n\n  /**\n   * Provides a hook to override how the emitter emits an event to a specific\n   * subscription. This allows you to set up logging and error boundaries\n   * specific to your environment.\n   *\n   * @param {EmitterSubscription} subscription\n   * @param {string} eventType\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   */\n\n  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n    var args = Array.prototype.slice.call(arguments, 2);\n    subscription.listener.apply(subscription.context, args);\n  };\n\n  return BaseEventEmitter;\n})();\n\nmodule.exports = BaseEventEmitter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/lib/BaseEventEmitter.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n * \n * @providesModule EmitterSubscription\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventSubscription = require('./EventSubscription');\n\n/**\n * EmitterSubscription represents a subscription with listener and context data.\n */\n\nvar EmitterSubscription = (function (_EventSubscription) {\n  _inherits(EmitterSubscription, _EventSubscription);\n\n  /**\n   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls\n   *   this subscription\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  function EmitterSubscription(subscriber, listener, context) {\n    _classCallCheck(this, EmitterSubscription);\n\n    _EventSubscription.call(this, subscriber);\n    this.listener = listener;\n    this.context = context;\n  }\n\n  return EmitterSubscription;\n})(EventSubscription);\n\nmodule.exports = EmitterSubscription;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/lib/EmitterSubscription.js\n ** module id = 4\n ** module chunks = 0\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n * \n * @providesModule EventSubscription\n * @typechecks\n */\n\n'use strict';\n\n/**\n * EventSubscription represents a subscription to a particular event. It can\n * remove its own subscription.\n */\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar EventSubscription = (function () {\n\n  /**\n   * @param {EventSubscriptionVendor} subscriber the subscriber that controls\n   *   this subscription.\n   */\n\n  function EventSubscription(subscriber) {\n    _classCallCheck(this, EventSubscription);\n\n    this.subscriber = subscriber;\n  }\n\n  /**\n   * Removes this subscription from the subscriber that controls it.\n   */\n\n  EventSubscription.prototype.remove = function remove() {\n    this.subscriber.removeSubscription(this);\n  };\n\n  return EventSubscription;\n})();\n\nmodule.exports = EventSubscription;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/lib/EventSubscription.js\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n * \n * @providesModule EventSubscriptionVendor\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * EventSubscriptionVendor stores a set of EventSubscriptions that are\n * subscribed to a particular event type.\n */\n\nvar EventSubscriptionVendor = (function () {\n  function EventSubscriptionVendor() {\n    _classCallCheck(this, EventSubscriptionVendor);\n\n    this._subscriptionsForType = {};\n    this._currentSubscription = null;\n  }\n\n  /**\n   * Adds a subscription keyed by an event type.\n   *\n   * @param {string} eventType\n   * @param {EventSubscription} subscription\n   */\n\n  EventSubscriptionVendor.prototype.addSubscription = function addSubscription(eventType, subscription) {\n    !(subscription.subscriber === this) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The subscriber of the subscription is incorrectly set.') : invariant(false) : undefined;\n    if (!this._subscriptionsForType[eventType]) {\n      this._subscriptionsForType[eventType] = [];\n    }\n    var key = this._subscriptionsForType[eventType].length;\n    this._subscriptionsForType[eventType].push(subscription);\n    subscription.eventType = eventType;\n    subscription.key = key;\n    return subscription;\n  };\n\n  /**\n   * Removes a bulk set of the subscriptions.\n   *\n   * @param {?string} eventType - Optional name of the event type whose\n   *   registered supscriptions to remove, if null remove all subscriptions.\n   */\n\n  EventSubscriptionVendor.prototype.removeAllSubscriptions = function removeAllSubscriptions(eventType) {\n    if (eventType === undefined) {\n      this._subscriptionsForType = {};\n    } else {\n      delete this._subscriptionsForType[eventType];\n    }\n  };\n\n  /**\n   * Removes a specific subscription. Instead of calling this function, call\n   * `subscription.remove()` directly.\n   *\n   * @param {object} subscription\n   */\n\n  EventSubscriptionVendor.prototype.removeSubscription = function removeSubscription(subscription) {\n    var eventType = subscription.eventType;\n    var key = subscription.key;\n\n    var subscriptionsForType = this._subscriptionsForType[eventType];\n    if (subscriptionsForType) {\n      delete subscriptionsForType[key];\n    }\n  };\n\n  /**\n   * Returns the array of subscriptions that are currently registered for the\n   * given event type.\n   *\n   * Note: This array can be potentially sparse as subscriptions are deleted\n   * from it when they are removed.\n   *\n   * TODO: This returns a nullable array. wat?\n   *\n   * @param {string} eventType\n   * @return {?array}\n   */\n\n  EventSubscriptionVendor.prototype.getSubscriptionsForType = function getSubscriptionsForType(eventType) {\n    return this._subscriptionsForType[eventType];\n  };\n\n  return EventSubscriptionVendor;\n})();\n\nmodule.exports = EventSubscriptionVendor;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/lib/EventSubscriptionVendor.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule emptyFunction\n */\n\n\"use strict\";\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nfunction emptyFunction() {}\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/emptyFunction.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}