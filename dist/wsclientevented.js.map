{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/fbemitter/lib/EmitterSubscription.js","webpack:///./node_modules/fbjs/lib/invariant.js","webpack:///./node_modules/fbemitter/index.js","webpack:///./node_modules/fbemitter/lib/BaseEventEmitter.js","webpack:///./node_modules/fbemitter/lib/EventSubscription.js","webpack:///./node_modules/fbemitter/lib/EventSubscriptionVendor.js","webpack:///./node_modules/fbjs/lib/emptyFunction.js","webpack:///./lib/index.js","webpack:///./lib/browser.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","EmitterSubscription","_EventSubscription","subscriber","listener","context","instance","Constructor","TypeError","_classCallCheck","this","subClass","superClass","constructor","writable","configurable","setPrototypeOf","__proto__","_inherits","validateFormat","format","condition","a","b","e","f","error","undefined","Error","args","argIndex","replace","framesToPop","fbemitter","EventEmitter","EventSubscriptionVendor","emptyFunction","invariant","BaseEventEmitter","_subscriber","_currentSubscription","addListener","eventType","addSubscription","once","emitter","removeCurrentListener","apply","arguments","removeAllListeners","removeAllSubscriptions","removeSubscription","listeners","subscriptions","getSubscriptionsForType","filter","thatReturnsTrue","map","subscription","emit","keys","ii","length","__emitToSubscription","concat","Array","slice","EventSubscription","remove","_subscriptionsForType","push","subscriptionsForType","makeEmptyFunction","arg","thatReturns","thatReturnsFalse","thatReturnsNull","thatReturnsThis","thatReturnsArgument","defaultMessageHandler","data","JSON","parse","_typeof","type","WsClientEvented","url","_this","protocols","options","reconnectAttempts","forcedClose","ws","sendTries","settings","autoOpen","autoReconnect","debug","forceCloseOnReload","reconnectInterval","reconnectDecay","timeoutInterval","binaryType","payloadItemName","maxReconnects","maxSendTries","maxReconnectTimeout","onBeforeWsOpen","onWsOpen","onWsMessage","onWsClose","onWsError","onWsTimeout","forEach","option","userEvt","evt","open","self","addEventListener","close","msg","console","warn","callback","_this2","payload","readyState","WebSocket","CONNECTING","setTimeout","send","CLOSING","CLOSED","OPEN","stringify","_this3","reconnecting","connectTimeOut","clearTimeout","timeout","Math","pow","code","reason","window"],"mappings":"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","file":"wsclientevented.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n * \n * @providesModule EmitterSubscription\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventSubscription = require('./EventSubscription');\n\n/**\n * EmitterSubscription represents a subscription with listener and context data.\n */\n\nvar EmitterSubscription = (function (_EventSubscription) {\n  _inherits(EmitterSubscription, _EventSubscription);\n\n  /**\n   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls\n   *   this subscription\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  function EmitterSubscription(subscriber, listener, context) {\n    _classCallCheck(this, EmitterSubscription);\n\n    _EventSubscription.call(this, subscriber);\n    this.listener = listener;\n    this.context = context;\n  }\n\n  return EmitterSubscription;\n})(EventSubscription);\n\nmodule.exports = EmitterSubscription;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (process.env.NODE_ENV !== 'production') {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar fbemitter = {\n  EventEmitter: require('./lib/BaseEventEmitter'),\n  EmitterSubscription : require('./lib/EmitterSubscription')\n};\n\nmodule.exports = fbemitter;\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BaseEventEmitter\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar EmitterSubscription = require('./EmitterSubscription');\nvar EventSubscriptionVendor = require('./EventSubscriptionVendor');\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * @class BaseEventEmitter\n * @description\n * An EventEmitter is responsible for managing a set of listeners and publishing\n * events to them when it is told that such events happened. In addition to the\n * data for the given event it also sends a event control object which allows\n * the listeners/handlers to prevent the default behavior of the given event.\n *\n * The emitter is designed to be generic enough to support all the different\n * contexts in which one might want to emit events. It is a simple multicast\n * mechanism on top of which extra functionality can be composed. For example, a\n * more advanced emitter may use an EventHolder and EventFactory.\n */\n\nvar BaseEventEmitter = (function () {\n  /**\n   * @constructor\n   */\n\n  function BaseEventEmitter() {\n    _classCallCheck(this, BaseEventEmitter);\n\n    this._subscriber = new EventSubscriptionVendor();\n    this._currentSubscription = null;\n  }\n\n  /**\n   * Adds a listener to be invoked when events of the specified type are\n   * emitted. An optional calling context may be provided. The data arguments\n   * emitted will be passed to the listener function.\n   *\n   * TODO: Annotate the listener arg's type. This is tricky because listeners\n   *       can be invoked with varargs.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\n    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n  };\n\n  /**\n   * Similar to addListener, except that the listener is removed after it is\n   * invoked once.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke only once when the\n   *   specified event is emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\n    var emitter = this;\n    return this.addListener(eventType, function () {\n      emitter.removeCurrentListener();\n      listener.apply(context, arguments);\n    });\n  };\n\n  /**\n   * Removes all of the registered listeners, including those registered as\n   * listener maps.\n   *\n   * @param {?string} eventType - Optional name of the event whose registered\n   *   listeners to remove\n   */\n\n  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\n    this._subscriber.removeAllSubscriptions(eventType);\n  };\n\n  /**\n   * Provides an API that can be called during an eventing cycle to remove the\n   * last listener that was invoked. This allows a developer to provide an event\n   * object that can remove the listener (or listener map) during the\n   * invocation.\n   *\n   * If it is called when not inside of an emitting cycle it will throw.\n   *\n   * @throws {Error} When called not during an eventing cycle\n   *\n   * @example\n   *   var subscription = emitter.addListenerMap({\n   *     someEvent: function(data, event) {\n   *       console.log(data);\n   *       emitter.removeCurrentListener();\n   *     }\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   *   emitter.emit('someEvent', 'def'); // does not log anything\n   */\n\n  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\n    !!!this._currentSubscription ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\n    this._subscriber.removeSubscription(this._currentSubscription);\n  };\n\n  /**\n   * Returns an array of listeners that are currently registered for the given\n   * event.\n   *\n   * @param {string} eventType - Name of the event to query\n   * @return {array}\n   */\n\n  BaseEventEmitter.prototype.listeners = function listeners(eventType) /* TODO: Array<EventSubscription> */{\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n      return subscription.listener;\n    }) : [];\n  };\n\n  /**\n   * Emits an event of the given type with the given data. All handlers of that\n   * particular type will be notified.\n   *\n   * @param {string} eventType - Name of the event to emit\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   *\n   * @example\n   *   emitter.addListener('someEvent', function(message) {\n   *     console.log(message);\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   */\n\n  BaseEventEmitter.prototype.emit = function emit(eventType) {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    if (subscriptions) {\n      var keys = Object.keys(subscriptions);\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        var subscription = subscriptions[key];\n        // The subscription may have been removed during this event loop.\n        if (subscription) {\n          this._currentSubscription = subscription;\n          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n        }\n      }\n      this._currentSubscription = null;\n    }\n  };\n\n  /**\n   * Provides a hook to override how the emitter emits an event to a specific\n   * subscription. This allows you to set up logging and error boundaries\n   * specific to your environment.\n   *\n   * @param {EmitterSubscription} subscription\n   * @param {string} eventType\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   */\n\n  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n    var args = Array.prototype.slice.call(arguments, 2);\n    subscription.listener.apply(subscription.context, args);\n  };\n\n  return BaseEventEmitter;\n})();\n\nmodule.exports = BaseEventEmitter;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventSubscription\n * @typechecks\n */\n\n'use strict';\n\n/**\n * EventSubscription represents a subscription to a particular event. It can\n * remove its own subscription.\n */\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar EventSubscription = (function () {\n\n  /**\n   * @param {EventSubscriptionVendor} subscriber the subscriber that controls\n   *   this subscription.\n   */\n\n  function EventSubscription(subscriber) {\n    _classCallCheck(this, EventSubscription);\n\n    this.subscriber = subscriber;\n  }\n\n  /**\n   * Removes this subscription from the subscriber that controls it.\n   */\n\n  EventSubscription.prototype.remove = function remove() {\n    if (this.subscriber) {\n      this.subscriber.removeSubscription(this);\n      this.subscriber = null;\n    }\n  };\n\n  return EventSubscription;\n})();\n\nmodule.exports = EventSubscription;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n * \n * @providesModule EventSubscriptionVendor\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * EventSubscriptionVendor stores a set of EventSubscriptions that are\n * subscribed to a particular event type.\n */\n\nvar EventSubscriptionVendor = (function () {\n  function EventSubscriptionVendor() {\n    _classCallCheck(this, EventSubscriptionVendor);\n\n    this._subscriptionsForType = {};\n    this._currentSubscription = null;\n  }\n\n  /**\n   * Adds a subscription keyed by an event type.\n   *\n   * @param {string} eventType\n   * @param {EventSubscription} subscription\n   */\n\n  EventSubscriptionVendor.prototype.addSubscription = function addSubscription(eventType, subscription) {\n    !(subscription.subscriber === this) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The subscriber of the subscription is incorrectly set.') : invariant(false) : undefined;\n    if (!this._subscriptionsForType[eventType]) {\n      this._subscriptionsForType[eventType] = [];\n    }\n    var key = this._subscriptionsForType[eventType].length;\n    this._subscriptionsForType[eventType].push(subscription);\n    subscription.eventType = eventType;\n    subscription.key = key;\n    return subscription;\n  };\n\n  /**\n   * Removes a bulk set of the subscriptions.\n   *\n   * @param {?string} eventType - Optional name of the event type whose\n   *   registered supscriptions to remove, if null remove all subscriptions.\n   */\n\n  EventSubscriptionVendor.prototype.removeAllSubscriptions = function removeAllSubscriptions(eventType) {\n    if (eventType === undefined) {\n      this._subscriptionsForType = {};\n    } else {\n      delete this._subscriptionsForType[eventType];\n    }\n  };\n\n  /**\n   * Removes a specific subscription. Instead of calling this function, call\n   * `subscription.remove()` directly.\n   *\n   * @param {object} subscription\n   */\n\n  EventSubscriptionVendor.prototype.removeSubscription = function removeSubscription(subscription) {\n    var eventType = subscription.eventType;\n    var key = subscription.key;\n\n    var subscriptionsForType = this._subscriptionsForType[eventType];\n    if (subscriptionsForType) {\n      delete subscriptionsForType[key];\n    }\n  };\n\n  /**\n   * Returns the array of subscriptions that are currently registered for the\n   * given event type.\n   *\n   * Note: This array can be potentially sparse as subscriptions are deleted\n   * from it when they are removed.\n   *\n   * TODO: This returns a nullable array. wat?\n   *\n   * @param {string} eventType\n   * @return {?array}\n   */\n\n  EventSubscriptionVendor.prototype.getSubscriptionsForType = function getSubscriptionsForType(eventType) {\n    return this._subscriptionsForType[eventType];\n  };\n\n  return EventSubscriptionVendor;\n})();\n\nmodule.exports = EventSubscriptionVendor;","\"use strict\";\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;","/* eslint no-console: 0 */\nimport { EventEmitter } from 'fbemitter';\n\n/**\n * Default regular emitter\n * @param {MessageEvent} e Original websocket event\n * @param {WsClientEvented} instance\n */\nconst defaultMessageHandler = (e, instance) => {\n  const data = JSON.parse(e.data);\n  const responseType = typeof data;\n\n  if (responseType === 'object' && data.type) {\n    instance.emitter.emit(data.type, e, data);\n  }\n};\n\n/**\n * WSClientEvented - WebSocket Client with event emission\n * @author Weblogixx (cs@weblogixx.de)\n *\n * @example let wsClient = new WsClientEvented('ws://localhost:123', 'example-protocol', {\n *   autoOpen: false\n * });\n *\n * Available options:\n * bool autoOpen [default: true] Automatically connect the websocket on initialisation?\n * bool autoReconnect [default: true] Automatically reconnect the websocket if connection is lost?\n * bool debug [default: false] Show debug output?\n * bool forceCloseOnReload [default: false] Send a forced close on browser reload? Only available when using the client in the main thread!\n * int reconnectInterval [default: 1000] Delay in ms for reconnect tries\n * float reconnectDecay [default 1.5] Factor for reconnects\n * int timeoutInterval [default: 2000] Time in ms to wait for connects\n * string binaryType [default: blob] Binary type for websocket transmission\n * string payloadItemName [default: payload] Send key for send items\n * int maxReconnects [default: null] Maximal amount of reconnects. Set to null for inifinite\n * int maxReconnectTimeout [default: 5000] Maximal amount of milliseconds to wait for reconnects\n * int maxSendTries [default: 10] Maximal amount of tries for ws send to fail for the same request\n * function onBeforeWsOpen [default: null] Called before WebSocket connections are established\n * function onWsOpen [default: null] Called when a WebSocket connection becomes ready\n * function onWsMessage [default: defaultMessageHandler] Called on all WebSocket onMessage events. Defaults to emitting via fbemitter\n * function onWsClose [default: null] Called when a WebSocket connection is closed\n * function onWsError [default: null] Called when a WebSocket connection throws errors\n * function onWsTimeout [default: null] Called when a WebSocket connection times out\n */\nexport default class WsClientEvented {\n\n  /**\n   * Create a new instance of WsClientEvent\n   * @param {String} url Url to connect to\n   * @param {String|Array} protocols List of protocols [optional]\n   * @param {Object} options Options to pass in [optional]\n   */\n  constructor(url, protocols = '', options = {}) {\n\n    // Instanciate a new event emitter\n    this.emitter = new EventEmitter();\n\n    this.url = url;\n    this.protocols = protocols && protocols.length > 0 ? protocols : null;\n\n    // How often did the websocket retry to connect?\n    this.reconnectAttempts = 0;\n\n    // Set to true to indicate no reconnect should take place\n    this.forcedClose = false;\n\n    // The websocket instance\n    this.ws = null;\n\n    // List of tries for each send request\n    this.sendTries = {};\n\n    // Default settings\n    this.settings = {\n      autoOpen: true,\n      autoReconnect: true,\n      debug: false,\n      forceCloseOnReload: false,\n      reconnectInterval: 1000,\n      reconnectDecay: 1.5,\n      timeoutInterval: 2000,\n      binaryType: 'blob',\n      payloadItemName: 'payload',\n      maxReconnects: null,\n      maxSendTries: 10,\n      maxReconnectTimeout: 5000,\n      onBeforeWsOpen: null,\n      onWsOpen: null,\n      onWsMessage: defaultMessageHandler.bind(this),\n      onWsClose: null,\n      onWsError: null,\n      onWsTimeout: null,\n    };\n\n    // Merge settings with defaults\n    Object.keys(options).forEach((option) => {\n      this.settings[option] = options[option];\n    });\n\n    // Attach all active listeners\n    ['onBeforeWsOpen', 'onWsOpen', 'onWsMessage', 'onWsClose', 'onWsError', 'onWsTimeout'].forEach((userEvt) => {\n      if (typeof this.settings[userEvt] === 'function') {\n        this.emitter.addListener(userEvt, (evt) => {\n          this.settings[userEvt](evt, this);\n        });\n      }\n    });\n\n    if (this.settings.autoOpen) {\n      this.open();\n    }\n\n    if (this.settings.forceCloseOnReload) {\n      self.addEventListener('beforeunload', () => {\n        this.close();\n      });\n    }\n  }\n\n  /**\n   * Output debug information (only if debug setting enabled)\n   * @param  {String} msg Message to output\n   */\n  debug(msg) {\n    if (this.settings.debug) {\n      console.warn(msg);\n    }\n  }\n\n  /**\n   * Add a new event listener\n   * @param {String} evt Name of the event\n   * @param {Function} callback Function to attach\n   * @return {WsClientEvented}\n   */\n  addListener(evt, callback) {\n    this.emitter.addListener(evt, callback);\n    return this;\n  }\n\n  /**\n   * Removes all listeners with a given name\n   * @param  {String} evt\n   * @return {WsClientEvented}\n   */\n  removeListener(evt) {\n    this.emitter.removeAllListeners(evt);\n    return this;\n  }\n\n  /**\n   * Send a new request\n   * @param  {String} event Event to send\n   * @param  {Object|String} payload Data to send as payload [optional]\n   * @return {WsClientEvent}\n   */\n  send(type, payload = {}) {\n\n    // Skip if type is not given\n    if (!type) {\n      throw new Error(`Must provide an event type, provided: ${type}`);\n    }\n\n    // Only send if the connection is available.\n    if (!this.ws) {\n      if (this.settings.autoReconnect) {\n        this.open();\n      } else {\n        this.debug(`Tried to send event ${type}, but forced close was set. Please open the connection manually via #open!`);\n        return this;\n      }\n    }\n\n    // Add the item to the send try list\n    if (typeof this.sendTries[type] === 'undefined') {\n      this.sendTries[type] = 1;\n    }\n\n    this.debug(`Trying to send event ${type} for the ${this.sendTries[type]} time...`);\n\n    switch (this.ws.readyState) {\n\n      // If the socket is in connecting state, try it again in a couple of ms\n      case WebSocket.CONNECTING:\n\n        // Skip trying to send the request if we reached the maximum\n        if (this.sendTries[type] >= this.settings.maxSendTries) {\n          this.debug(`WS still in connecting state, giving up after ${this.settings.maxSendTries} tries for event ${type}`);\n          return this;\n        }\n\n        this.sendTries[type] += 1;\n        self.setTimeout(() => {\n          this.send(type, payload);\n        }, 500);\n        break;\n\n      // If the socket is getting closed or is closed, reopen it\n      case WebSocket.CLOSING:\n      case WebSocket.CLOSED:\n\n        // Skip trying to send the request if we reached the maximum\n        if (this.sendTries[type] >= this.settings.maxSendTries) {\n          this.debug(`WS still in closing state, giving up after ${this.settings.maxSendTries} tries for event ${type}`);\n          return this;\n        }\n\n        this.sendTries[type] += 1;\n        this.open(true);\n        self.setTimeout(() => {\n          this.send(type, payload);\n        }, 500);\n        break;\n\n      // If the websocket is open, just send\n      case WebSocket.OPEN:\n      default:\n\n        this.ws.send(JSON.stringify({\n          type,\n          [this.settings.payloadItemName]: payload,\n        }));\n\n        // Request went through, reset the try counter\n        this.sendTries[type] = 1;\n    }\n\n    return this;\n  }\n\n  /**\n   * Open the websocket\n   * @param {Boolean} reconnecting Status of the connection (true if a forced reconnect was done)\n   * @return {WsClientEvent}\n   */\n  open(reconnecting = false) {\n\n    // If the maximal amounts of reconnects is hit, just exit\n    if (this.settings.maxReconnects && this.reconnectAttempts >= this.settings.maxReconnects) {\n      this.debug('Maximal amount of reconnects reached, giving up! Please call #open by yourself to retry.');\n      return this;\n    }\n\n    // Close the websocket if it is already open\n    if (!reconnecting && this.ws) {\n      this.close();\n    }\n\n    this.emitter.emit('onBeforeWsOpen');\n\n    // Automatically disconnect after a given period of time\n    const connectTimeOut = setTimeout(() => {\n      this.debug('WS Connection timed out');\n      this.emitter.emit('onWsTimeout');\n    }, this.settings.timeoutInterval);\n\n    // Create the new websocket instance\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.binaryType = this.settings.binaryType;\n\n    // Add the needed events\n    this.ws.addEventListener('open', (e) => {\n\n      // Clean up the connect timeout after open was fired\n      clearTimeout(connectTimeOut);\n\n      this.emitter.emit('onWsOpen', e, this);\n\n      this.debug(`WS connection successfully opened on attemp#${this.reconnectAttempts}.`);\n\n      // We are connected, so reset the reconnect attempts\n      this.reconnectAttempts = 0;\n\n      // Reset the send queue\n      this.sendTries = {};\n    });\n\n    this.ws.addEventListener('message', (e) => {\n      this.emitter.emit('onWsMessage', e, this);\n    });\n\n    this.ws.addEventListener('close', (e) => {\n\n      clearTimeout(connectTimeOut);\n\n      this.emitter.emit('onWsClose', e, this);\n\n      // Try to reconnect if the close action was not forced via WsClientEvented#close\n      if (!this.forcedClose && this.settings.autoReconnect) {\n\n        // Reconnect the websocket automatically\n        // @credits: https://github.com/joewalnes/reconnecting-websocket/\n        let timeout = this.settings.reconnectInterval * Math.pow(this.settings.reconnectDecay, this.reconnectAttempts);\n        if (timeout > this.settings.maxReconnectTimeout) {\n          timeout = this.settings.maxReconnectTimeout;\n        }\n        this.debug(`Auto reconnect required, trying again in ${timeout} ms...`);\n\n        setTimeout(() => {\n          this.reconnectAttempts += 1;\n          this.open(true);\n          this.debug('WS connection timed out, trying to reconnect...');\n        }, timeout);\n      } else if (this.forcedClose) {\n        this.forcedClose = false;\n        this.debug('WS forced closing the connection');\n      }\n    });\n\n    this.ws.addEventListener('error', (e) => {\n      this.emitter.emit('onWsError', e, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * Close the websocket if it is open\n   * @param  {Number} code The code to send [optional]\n   * @param  {String} reason The reason for closing [optional]\n   * @return {WsClientEvent}\n   */\n  close(code = 1000, reason = '') {\n    if (this.ws) {\n      this.forcedClose = true;\n      this.reconnectAttempts = 0;\n      this.sendTries = {};\n      this.ws.close(code, reason);\n      this.ws = null;\n    }\n    return this;\n  }\n}\n","import WsClientEvented from './index';\n\nwindow.WsClientEvented = WsClientEvented;\n"],"sourceRoot":""}