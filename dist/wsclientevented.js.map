{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/fbemitter/lib/EmitterSubscription.js","webpack:///./node_modules/fbjs/lib/invariant.js","webpack:///./node_modules/fbemitter/index.js","webpack:///./node_modules/fbemitter/lib/BaseEventEmitter.js","webpack:///./node_modules/fbemitter/lib/EventSubscription.js","webpack:///./node_modules/fbemitter/lib/EventSubscriptionVendor.js","webpack:///./node_modules/fbjs/lib/emptyFunction.js","webpack:///./lib/index.js","webpack:///./lib/browser.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","EmitterSubscription","_EventSubscription","subscriber","listener","context","instance","Constructor","TypeError","_classCallCheck","this","subClass","superClass","constructor","writable","configurable","setPrototypeOf","__proto__","_inherits","condition","format","a","b","e","f","error","undefined","Error","args","argIndex","replace","framesToPop","fbemitter","EventEmitter","EventSubscriptionVendor","emptyFunction","invariant","BaseEventEmitter","_subscriber","_currentSubscription","addListener","eventType","addSubscription","once","emitter","removeCurrentListener","apply","arguments","removeAllListeners","removeAllSubscriptions","removeSubscription","listeners","subscriptions","getSubscriptionsForType","filter","thatReturnsTrue","map","subscription","emit","keys","ii","length","__emitToSubscription","concat","Array","slice","EventSubscription","remove","_subscriptionsForType","push","subscriptionsForType","makeEmptyFunction","arg","thatReturns","thatReturnsFalse","thatReturnsNull","thatReturnsThis","thatReturnsArgument","defaultMessageHandler","data","JSON","parse","type","WsClientEvented","url","protocols","options","reconnectAttempts","forcedClose","ws","sendTries","settings","autoOpen","autoReconnect","debug","forceCloseOnReload","reconnectInterval","reconnectDecay","timeoutInterval","binaryType","payloadItemName","maxReconnects","maxSendTries","maxReconnectTimeout","onBeforeWsOpen","onWsOpen","onWsMessage","onWsClose","onWsError","onMaxReconnects","onWsTimeout","forEach","option","userEvt","evt","open","self","addEventListener","close","msg","console","warn","callback","payload","readyState","WebSocket","CONNECTING","setTimeout","send","CLOSING","CLOSED","OPEN","stringify","reconnecting","connectTimeOut","clearTimeout","timeout","Math","pow","code","reason","window"],"mappings":"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","file":"wsclientevented.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n * \n * @providesModule EmitterSubscription\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventSubscription = require('./EventSubscription');\n\n/**\n * EmitterSubscription represents a subscription with listener and context data.\n */\n\nvar EmitterSubscription = (function (_EventSubscription) {\n  _inherits(EmitterSubscription, _EventSubscription);\n\n  /**\n   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls\n   *   this subscription\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  function EmitterSubscription(subscriber, listener, context) {\n    _classCallCheck(this, EmitterSubscription);\n\n    _EventSubscription.call(this, subscriber);\n    this.listener = listener;\n    this.context = context;\n  }\n\n  return EmitterSubscription;\n})(EventSubscription);\n\nmodule.exports = EmitterSubscription;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (process.env.NODE_ENV !== 'production') {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar fbemitter = {\n  EventEmitter: require('./lib/BaseEventEmitter'),\n  EmitterSubscription : require('./lib/EmitterSubscription')\n};\n\nmodule.exports = fbemitter;\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BaseEventEmitter\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar EmitterSubscription = require('./EmitterSubscription');\nvar EventSubscriptionVendor = require('./EventSubscriptionVendor');\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * @class BaseEventEmitter\n * @description\n * An EventEmitter is responsible for managing a set of listeners and publishing\n * events to them when it is told that such events happened. In addition to the\n * data for the given event it also sends a event control object which allows\n * the listeners/handlers to prevent the default behavior of the given event.\n *\n * The emitter is designed to be generic enough to support all the different\n * contexts in which one might want to emit events. It is a simple multicast\n * mechanism on top of which extra functionality can be composed. For example, a\n * more advanced emitter may use an EventHolder and EventFactory.\n */\n\nvar BaseEventEmitter = (function () {\n  /**\n   * @constructor\n   */\n\n  function BaseEventEmitter() {\n    _classCallCheck(this, BaseEventEmitter);\n\n    this._subscriber = new EventSubscriptionVendor();\n    this._currentSubscription = null;\n  }\n\n  /**\n   * Adds a listener to be invoked when events of the specified type are\n   * emitted. An optional calling context may be provided. The data arguments\n   * emitted will be passed to the listener function.\n   *\n   * TODO: Annotate the listener arg's type. This is tricky because listeners\n   *       can be invoked with varargs.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\n    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n  };\n\n  /**\n   * Similar to addListener, except that the listener is removed after it is\n   * invoked once.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke only once when the\n   *   specified event is emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\n    var emitter = this;\n    return this.addListener(eventType, function () {\n      emitter.removeCurrentListener();\n      listener.apply(context, arguments);\n    });\n  };\n\n  /**\n   * Removes all of the registered listeners, including those registered as\n   * listener maps.\n   *\n   * @param {?string} eventType - Optional name of the event whose registered\n   *   listeners to remove\n   */\n\n  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\n    this._subscriber.removeAllSubscriptions(eventType);\n  };\n\n  /**\n   * Provides an API that can be called during an eventing cycle to remove the\n   * last listener that was invoked. This allows a developer to provide an event\n   * object that can remove the listener (or listener map) during the\n   * invocation.\n   *\n   * If it is called when not inside of an emitting cycle it will throw.\n   *\n   * @throws {Error} When called not during an eventing cycle\n   *\n   * @example\n   *   var subscription = emitter.addListenerMap({\n   *     someEvent: function(data, event) {\n   *       console.log(data);\n   *       emitter.removeCurrentListener();\n   *     }\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   *   emitter.emit('someEvent', 'def'); // does not log anything\n   */\n\n  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\n    !!!this._currentSubscription ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\n    this._subscriber.removeSubscription(this._currentSubscription);\n  };\n\n  /**\n   * Returns an array of listeners that are currently registered for the given\n   * event.\n   *\n   * @param {string} eventType - Name of the event to query\n   * @return {array}\n   */\n\n  BaseEventEmitter.prototype.listeners = function listeners(eventType) /* TODO: Array<EventSubscription> */{\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n      return subscription.listener;\n    }) : [];\n  };\n\n  /**\n   * Emits an event of the given type with the given data. All handlers of that\n   * particular type will be notified.\n   *\n   * @param {string} eventType - Name of the event to emit\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   *\n   * @example\n   *   emitter.addListener('someEvent', function(message) {\n   *     console.log(message);\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   */\n\n  BaseEventEmitter.prototype.emit = function emit(eventType) {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    if (subscriptions) {\n      var keys = Object.keys(subscriptions);\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        var subscription = subscriptions[key];\n        // The subscription may have been removed during this event loop.\n        if (subscription) {\n          this._currentSubscription = subscription;\n          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n        }\n      }\n      this._currentSubscription = null;\n    }\n  };\n\n  /**\n   * Provides a hook to override how the emitter emits an event to a specific\n   * subscription. This allows you to set up logging and error boundaries\n   * specific to your environment.\n   *\n   * @param {EmitterSubscription} subscription\n   * @param {string} eventType\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   */\n\n  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n    var args = Array.prototype.slice.call(arguments, 2);\n    subscription.listener.apply(subscription.context, args);\n  };\n\n  return BaseEventEmitter;\n})();\n\nmodule.exports = BaseEventEmitter;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventSubscription\n * @typechecks\n */\n\n'use strict';\n\n/**\n * EventSubscription represents a subscription to a particular event. It can\n * remove its own subscription.\n */\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar EventSubscription = (function () {\n\n  /**\n   * @param {EventSubscriptionVendor} subscriber the subscriber that controls\n   *   this subscription.\n   */\n\n  function EventSubscription(subscriber) {\n    _classCallCheck(this, EventSubscription);\n\n    this.subscriber = subscriber;\n  }\n\n  /**\n   * Removes this subscription from the subscriber that controls it.\n   */\n\n  EventSubscription.prototype.remove = function remove() {\n    if (this.subscriber) {\n      this.subscriber.removeSubscription(this);\n      this.subscriber = null;\n    }\n  };\n\n  return EventSubscription;\n})();\n\nmodule.exports = EventSubscription;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n * \n * @providesModule EventSubscriptionVendor\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * EventSubscriptionVendor stores a set of EventSubscriptions that are\n * subscribed to a particular event type.\n */\n\nvar EventSubscriptionVendor = (function () {\n  function EventSubscriptionVendor() {\n    _classCallCheck(this, EventSubscriptionVendor);\n\n    this._subscriptionsForType = {};\n    this._currentSubscription = null;\n  }\n\n  /**\n   * Adds a subscription keyed by an event type.\n   *\n   * @param {string} eventType\n   * @param {EventSubscription} subscription\n   */\n\n  EventSubscriptionVendor.prototype.addSubscription = function addSubscription(eventType, subscription) {\n    !(subscription.subscriber === this) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The subscriber of the subscription is incorrectly set.') : invariant(false) : undefined;\n    if (!this._subscriptionsForType[eventType]) {\n      this._subscriptionsForType[eventType] = [];\n    }\n    var key = this._subscriptionsForType[eventType].length;\n    this._subscriptionsForType[eventType].push(subscription);\n    subscription.eventType = eventType;\n    subscription.key = key;\n    return subscription;\n  };\n\n  /**\n   * Removes a bulk set of the subscriptions.\n   *\n   * @param {?string} eventType - Optional name of the event type whose\n   *   registered supscriptions to remove, if null remove all subscriptions.\n   */\n\n  EventSubscriptionVendor.prototype.removeAllSubscriptions = function removeAllSubscriptions(eventType) {\n    if (eventType === undefined) {\n      this._subscriptionsForType = {};\n    } else {\n      delete this._subscriptionsForType[eventType];\n    }\n  };\n\n  /**\n   * Removes a specific subscription. Instead of calling this function, call\n   * `subscription.remove()` directly.\n   *\n   * @param {object} subscription\n   */\n\n  EventSubscriptionVendor.prototype.removeSubscription = function removeSubscription(subscription) {\n    var eventType = subscription.eventType;\n    var key = subscription.key;\n\n    var subscriptionsForType = this._subscriptionsForType[eventType];\n    if (subscriptionsForType) {\n      delete subscriptionsForType[key];\n    }\n  };\n\n  /**\n   * Returns the array of subscriptions that are currently registered for the\n   * given event type.\n   *\n   * Note: This array can be potentially sparse as subscriptions are deleted\n   * from it when they are removed.\n   *\n   * TODO: This returns a nullable array. wat?\n   *\n   * @param {string} eventType\n   * @return {?array}\n   */\n\n  EventSubscriptionVendor.prototype.getSubscriptionsForType = function getSubscriptionsForType(eventType) {\n    return this._subscriptionsForType[eventType];\n  };\n\n  return EventSubscriptionVendor;\n})();\n\nmodule.exports = EventSubscriptionVendor;","\"use strict\";\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;","/* eslint no-console: 0 */\nimport { EventEmitter } from 'fbemitter';\n\n/**\n * Default regular emitter\n * @param {MessageEvent} e Original websocket event\n * @param {WsClientEvented} instance\n */\nconst defaultMessageHandler = (e, instance) => {\n  const data = JSON.parse(e.data);\n  const responseType = typeof data;\n\n  if (responseType === 'object' && data.type) {\n    instance.emitter.emit(data.type, e, data);\n  }\n};\n\n/**\n * WSClientEvented - WebSocket Client with event emission\n * @author Weblogixx (cs@weblogixx.de)\n *\n * @example let wsClient = new WsClientEvented('ws://localhost:123', 'example-protocol', {\n *   autoOpen: false\n * });\n *\n * Available options:\n * bool autoOpen [default: true] Automatically connect the websocket on initialisation?\n * bool autoReconnect [default: true] Automatically reconnect the websocket if connection is lost?\n * bool debug [default: false] Show debug output?\n * bool forceCloseOnReload [default: false] Send a forced close on browser reload? Only available when using the client in the main thread!\n * int reconnectInterval [default: 1000] Delay in ms for reconnect tries\n * float reconnectDecay [default 1.5] Factor for reconnects\n * int timeoutInterval [default: 2000] Time in ms to wait for connects\n * string binaryType [default: blob] Binary type for websocket transmission\n * string payloadItemName [default: payload] Send key for send items\n * int maxReconnects [default: null] Maximal amount of reconnects. Set to null for inifinite\n * int maxReconnectTimeout [default: 5000] Maximal amount of milliseconds to wait for reconnects\n * int maxSendTries [default: 10] Maximal amount of tries for ws send to fail for the same request\n * function onBeforeWsOpen [default: null] Called before WebSocket connections are established\n * function onWsOpen [default: null] Called when a WebSocket connection becomes ready\n * function onWsMessage [default: defaultMessageHandler] Called on all WebSocket onMessage events. Defaults to emitting via fbemitter\n * function onWsClose [default: null] Called when a WebSocket connection is closed\n * function onWsError [default: null] Called when a WebSocket connection throws errors\n * function onMaxReconnects [default: null] Called when the maximal amount of reconnects is reached\n * function onWsTimeout [default: null] Called when a WebSocket connection times out\n */\nexport default class WsClientEvented {\n\n  /**\n   * Create a new instance of WsClientEvent\n   * @param {String} url Url to connect to\n   * @param {String|Array} protocols List of protocols [optional]\n   * @param {Object} options Options to pass in [optional]\n   */\n  constructor(url, protocols = '', options = {}) {\n\n    // Instanciate a new event emitter\n    this.emitter = new EventEmitter();\n\n    this.url = url;\n    this.protocols = protocols && protocols.length > 0 ? protocols : null;\n\n    // How often did the websocket retry to connect?\n    this.reconnectAttempts = 0;\n\n    // Set to true to indicate no reconnect should take place\n    this.forcedClose = false;\n\n    // The websocket instance\n    this.ws = null;\n\n    // List of tries for each send request\n    this.sendTries = {};\n\n    // Default settings\n    this.settings = {\n      autoOpen: true,\n      autoReconnect: true,\n      debug: false,\n      forceCloseOnReload: false,\n      reconnectInterval: 1000,\n      reconnectDecay: 1.5,\n      timeoutInterval: 2000,\n      binaryType: 'blob',\n      payloadItemName: 'payload',\n      maxReconnects: null,\n      maxSendTries: 10,\n      maxReconnectTimeout: 5000,\n      onBeforeWsOpen: null,\n      onWsOpen: null,\n      onWsMessage: defaultMessageHandler.bind(this),\n      onWsClose: null,\n      onWsError: null,\n      onMaxReconnects: null,\n      onWsTimeout: null,\n    };\n\n    // Merge settings with defaults\n    Object.keys(options).forEach((option) => {\n      this.settings[option] = options[option];\n    });\n\n    // Attach all active listeners\n    ['onBeforeWsOpen', 'onWsOpen', 'onWsMessage', 'onWsClose', 'onWsError', 'onMaxReconnects', 'onWsTimeout'].forEach((userEvt) => {\n      if (typeof this.settings[userEvt] === 'function') {\n        this.emitter.addListener(userEvt, (evt) => {\n          this.settings[userEvt](evt, this);\n        });\n      }\n    });\n\n    if (this.settings.autoOpen) {\n      this.open();\n    }\n\n    if (this.settings.forceCloseOnReload) {\n      self.addEventListener('beforeunload', () => {\n        this.close();\n      });\n    }\n  }\n\n  /**\n   * Output debug information (only if debug setting enabled)\n   * @param  {String} msg Message to output\n   */\n  debug(msg) {\n    if (this.settings.debug) {\n      console.warn(msg);\n    }\n  }\n\n  /**\n   * Add a new event listener\n   * @param {String} evt Name of the event\n   * @param {Function} callback Function to attach\n   * @return {WsClientEvented}\n   */\n  addListener(evt, callback) {\n    this.emitter.addListener(evt, callback);\n    return this;\n  }\n\n  /**\n   * Removes all listeners with a given name\n   * @param  {String} evt\n   * @return {WsClientEvented}\n   */\n  removeListener(evt) {\n    this.emitter.removeAllListeners(evt);\n    return this;\n  }\n\n  /**\n   * Send a new request\n   * @param  {String} event Event to send\n   * @param  {Object|String} payload Data to send as payload [optional]\n   * @return {WsClientEvent}\n   */\n  send(type, payload = {}) {\n\n    // Skip if type is not given\n    if (!type) {\n      throw new Error(`Must provide an event type, provided: ${type}`);\n    }\n\n    // Only send if the connection is available.\n    if (!this.ws) {\n      if (this.settings.autoReconnect) {\n        this.open();\n      } else {\n        this.debug(`Tried to send event ${type}, but forced close was set. Please open the connection manually via #open!`);\n        return this;\n      }\n    }\n\n    // Add the item to the send try list\n    if (typeof this.sendTries[type] === 'undefined') {\n      this.sendTries[type] = 1;\n    }\n\n    this.debug(`Trying to send event ${type} for the ${this.sendTries[type]} time...`);\n\n    switch (this.ws.readyState) {\n\n      // If the socket is in connecting state, try it again in a couple of ms\n      case WebSocket.CONNECTING:\n\n        // Skip trying to send the request if we reached the maximum\n        if (this.sendTries[type] >= this.settings.maxSendTries) {\n          this.debug(`WS still in connecting state, giving up after ${this.settings.maxSendTries} tries for event ${type}`);\n          return this;\n        }\n\n        this.sendTries[type] += 1;\n        self.setTimeout(() => {\n          this.send(type, payload);\n        }, 500);\n        break;\n\n      // If the socket is getting closed or is closed, reopen it\n      case WebSocket.CLOSING:\n      case WebSocket.CLOSED:\n\n        // Skip trying to send the request if we reached the maximum\n        if (this.sendTries[type] >= this.settings.maxSendTries) {\n          this.debug(`WS still in closing state, giving up after ${this.settings.maxSendTries} tries for event ${type}`);\n          return this;\n        }\n\n        this.sendTries[type] += 1;\n        this.open(true);\n        self.setTimeout(() => {\n          this.send(type, payload);\n        }, 500);\n        break;\n\n      // If the websocket is open, just send\n      case WebSocket.OPEN:\n      default:\n\n        this.ws.send(JSON.stringify({\n          type,\n          [this.settings.payloadItemName]: payload,\n        }));\n\n        // Request went through, reset the try counter\n        this.sendTries[type] = 1;\n    }\n\n    return this;\n  }\n\n  /**\n   * Open the websocket\n   * @param {Boolean} reconnecting Status of the connection (true if a forced reconnect was done)\n   * @return {WsClientEvent}\n   */\n  open(reconnecting = false) {\n\n    // If the maximal amounts of reconnects is hit, just exit\n    if (this.settings.maxReconnects && this.reconnectAttempts >= this.settings.maxReconnects) {\n      this.debug('Maximal amount of reconnects reached, giving up! Please call #open by yourself to retry.');\n      this.emitter.emit('onMaxReconnects');\n      return this;\n    }\n\n    // Close the websocket if it is already open\n    if (!reconnecting && this.ws) {\n      this.close();\n    }\n\n    this.emitter.emit('onBeforeWsOpen');\n\n    // Automatically disconnect after a given period of time\n    const connectTimeOut = setTimeout(() => {\n      this.debug('WS Connection timed out');\n      this.emitter.emit('onWsTimeout');\n    }, this.settings.timeoutInterval);\n\n    // Create the new websocket instance\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.binaryType = this.settings.binaryType;\n\n    // Add the needed events\n    this.ws.addEventListener('open', (e) => {\n\n      // Clean up the connect timeout after open was fired\n      clearTimeout(connectTimeOut);\n\n      this.emitter.emit('onWsOpen', e, this);\n\n      this.debug(`WS connection successfully opened on attemp#${this.reconnectAttempts}.`);\n\n      // We are connected, so reset the reconnect attempts\n      this.reconnectAttempts = 0;\n\n      // Reset the send queue\n      this.sendTries = {};\n    });\n\n    this.ws.addEventListener('message', (e) => {\n      this.emitter.emit('onWsMessage', e, this);\n    });\n\n    this.ws.addEventListener('close', (e) => {\n\n      clearTimeout(connectTimeOut);\n\n      this.emitter.emit('onWsClose', e, this);\n\n      // Try to reconnect if the close action was not forced via WsClientEvented#close\n      if (!this.forcedClose && this.settings.autoReconnect) {\n\n        // Reconnect the websocket automatically\n        // @credits: https://github.com/joewalnes/reconnecting-websocket/\n        let timeout = this.settings.reconnectInterval * Math.pow(this.settings.reconnectDecay, this.reconnectAttempts);\n        if (timeout > this.settings.maxReconnectTimeout) {\n          timeout = this.settings.maxReconnectTimeout;\n        }\n        this.debug(`Auto reconnect required, trying again in ${timeout} ms...`);\n\n        setTimeout(() => {\n          this.reconnectAttempts += 1;\n          this.open(true);\n          this.debug('WS connection timed out, trying to reconnect...');\n        }, timeout);\n      } else if (this.forcedClose) {\n        this.forcedClose = false;\n        this.debug('WS forced closing the connection');\n      }\n    });\n\n    this.ws.addEventListener('error', (e) => {\n      this.emitter.emit('onWsError', e, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * Close the websocket if it is open\n   * @param  {Number} code The code to send [optional]\n   * @param  {String} reason The reason for closing [optional]\n   * @return {WsClientEvent}\n   */\n  close(code = 1000, reason = '') {\n    if (this.ws) {\n      this.forcedClose = true;\n      this.reconnectAttempts = 0;\n      this.sendTries = {};\n      this.ws.close(code, reason);\n      this.ws = null;\n    }\n    return this;\n  }\n}\n","import WsClientEvented from './index';\n\nwindow.WsClientEvented = WsClientEvented;\n"],"sourceRoot":""}