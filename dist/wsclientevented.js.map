{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/fbemitter/lib/EmitterSubscription.js","webpack:///./node_modules/fbjs/lib/invariant.js","webpack:///./node_modules/fbemitter/index.js","webpack:///./node_modules/fbemitter/lib/BaseEventEmitter.js","webpack:///./node_modules/fbemitter/lib/EventSubscription.js","webpack:///./node_modules/fbemitter/lib/EventSubscriptionVendor.js","webpack:///./node_modules/fbjs/lib/emptyFunction.js","webpack:///./lib/index.js","webpack:///./lib/browser.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","EmitterSubscription","_EventSubscription","subClass","superClass","subscriber","listener","context","_this","this","constructor","__proto__","validateFormat","format","condition","_len","arguments","length","args","Array","_key","error","undefined","Error","argIndex","replace","String","framesToPop","fbemitter","EventEmitter","EventSubscriptionVendor","invariant","emptyFunction","BaseEventEmitter","_subscriber","_currentSubscription","_proto","addListener","eventType","addSubscription","once","emitter","removeCurrentListener","apply","removeAllListeners","removeAllSubscriptions","removeSubscription","listeners","subscriptions","getSubscriptionsForType","filter","thatReturnsTrue","map","subscription","emit","keys","ii","__emitToSubscription","concat","slice","EventSubscription","remove","_subscriptionsForType","push","subscriptionsForType","makeEmptyFunction","arg","thatReturns","thatReturnsFalse","thatReturnsNull","thatReturnsThis","thatReturnsArgument","defaultMessageHandler","e","instance","data","JSON","parse","type","WsClientEvented","url","protocols","options","reconnectAttempts","forcedClose","ws","sendTries","settings","autoOpen","autoReconnect","debug","forceCloseOnReload","reconnectInterval","reconnectDecay","timeoutInterval","binaryType","payloadItemName","maxReconnects","maxSendTries","maxReconnectTimeout","onBeforeWsOpen","onWsOpen","onWsMessage","onWsClose","onWsError","onMaxReconnects","onWsTimeout","forEach","option","userEvt","evt","open","self","addEventListener","close","msg","console","warn","callback","payload","readyState","WebSocket","CONNECTING","setTimeout","send","CLOSING","CLOSED","OPEN","stringify","reconnecting","connectTimeOut","clearTimeout","timeout","Math","pow","code","reason","window"],"mappings":"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","file":"wsclientevented.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule EmitterSubscription\r\n * @typechecks\r\n */\n'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar EventSubscription = require(\"./EventSubscription.js\");\n/**\r\n * EmitterSubscription represents a subscription with listener and context data.\r\n */\n\n\nvar EmitterSubscription = /*#__PURE__*/function (_EventSubscription) {\n  _inheritsLoose(EmitterSubscription, _EventSubscription);\n\n  /**\r\n   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls\r\n   *   this subscription\r\n   * @param {function} listener - Function to invoke when the specified event is\r\n   *   emitted\r\n   * @param {*} context - Optional context object to use when invoking the\r\n   *   listener\r\n   */\n  function EmitterSubscription(subscriber, listener, context) {\n    var _this;\n\n    _this = _EventSubscription.call(this, subscriber) || this;\n    _this.listener = listener;\n    _this.context = context;\n    return _this;\n  }\n\n  return EmitterSubscription;\n}(EventSubscription);\n\nmodule.exports = EmitterSubscription;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n'use strict';\n\nvar validateFormat = process.env.NODE_ENV !== \"production\" ? function (format) {\n  if (format === undefined) {\n    throw new Error('invariant(...): Second argument must be a string.');\n  }\n} : function (format) {};\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments to provide\n * information about what broke and what you were expecting.\n *\n * The invariant message will be stripped in production, but the invariant will\n * remain to ensure logic does not differ in production.\n */\n\nfunction invariant(condition, format) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return String(args[argIndex++]);\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // Skip invariant's own stack frame.\n\n    throw error;\n  }\n}\n\nmodule.exports = invariant;","/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n */\r\n\r\nvar fbemitter = {\r\n  EventEmitter: require('./lib/BaseEventEmitter'),\r\n  EmitterSubscription : require('./lib/EmitterSubscription')\r\n};\r\n\r\nmodule.exports = fbemitter;\r\n","\"use strict\";\n\n/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule BaseEventEmitter\r\n * @typechecks\r\n */\nvar EmitterSubscription = require(\"./EmitterSubscription.js\");\n\nvar EventSubscriptionVendor = require(\"./EventSubscriptionVendor.js\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar emptyFunction = require(\"fbjs/lib/emptyFunction\");\n/**\r\n * @class BaseEventEmitter\r\n * @description\r\n * An EventEmitter is responsible for managing a set of listeners and publishing\r\n * events to them when it is told that such events happened. In addition to the\r\n * data for the given event it also sends a event control object which allows\r\n * the listeners/handlers to prevent the default behavior of the given event.\r\n *\r\n * The emitter is designed to be generic enough to support all the different\r\n * contexts in which one might want to emit events. It is a simple multicast\r\n * mechanism on top of which extra functionality can be composed. For example, a\r\n * more advanced emitter may use an EventHolder and EventFactory.\r\n */\n\n\nvar BaseEventEmitter = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   */\n  function BaseEventEmitter() {\n    this._subscriber = new EventSubscriptionVendor();\n    this._currentSubscription = null;\n  }\n  /**\r\n   * Adds a listener to be invoked when events of the specified type are\r\n   * emitted. An optional calling context may be provided. The data arguments\r\n   * emitted will be passed to the listener function.\r\n   *\r\n   * TODO: Annotate the listener arg's type. This is tricky because listeners\r\n   *       can be invoked with varargs.\r\n   *\r\n   * @param {string} eventType - Name of the event to listen to\r\n   * @param {function} listener - Function to invoke when the specified event is\r\n   *   emitted\r\n   * @param {*} context - Optional context object to use when invoking the\r\n   *   listener\r\n   */\n\n\n  var _proto = BaseEventEmitter.prototype;\n\n  _proto.addListener = function addListener(eventType, listener, context) {\n    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n  }\n  /**\r\n   * Similar to addListener, except that the listener is removed after it is\r\n   * invoked once.\r\n   *\r\n   * @param {string} eventType - Name of the event to listen to\r\n   * @param {function} listener - Function to invoke only once when the\r\n   *   specified event is emitted\r\n   * @param {*} context - Optional context object to use when invoking the\r\n   *   listener\r\n   */\n  ;\n\n  _proto.once = function once(eventType, listener, context) {\n    var emitter = this;\n    return this.addListener(eventType, function () {\n      emitter.removeCurrentListener();\n      listener.apply(context, arguments);\n    });\n  }\n  /**\r\n   * Removes all of the registered listeners, including those registered as\r\n   * listener maps.\r\n   *\r\n   * @param {?string} eventType - Optional name of the event whose registered\r\n   *   listeners to remove\r\n   */\n  ;\n\n  _proto.removeAllListeners = function removeAllListeners(eventType) {\n    this._subscriber.removeAllSubscriptions(eventType);\n  }\n  /**\r\n   * Provides an API that can be called during an eventing cycle to remove the\r\n   * last listener that was invoked. This allows a developer to provide an event\r\n   * object that can remove the listener (or listener map) during the\r\n   * invocation.\r\n   *\r\n   * If it is called when not inside of an emitting cycle it will throw.\r\n   *\r\n   * @throws {Error} When called not during an eventing cycle\r\n   *\r\n   * @example\r\n   *   var subscription = emitter.addListenerMap({\r\n   *     someEvent: function(data, event) {\r\n   *       console.log(data);\r\n   *       emitter.removeCurrentListener();\r\n   *     }\r\n   *   });\r\n   *\r\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\r\n   *   emitter.emit('someEvent', 'def'); // does not log anything\r\n   */\n  ;\n\n  _proto.removeCurrentListener = function removeCurrentListener() {\n    !!!this._currentSubscription ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : void 0;\n\n    this._subscriber.removeSubscription(this._currentSubscription);\n  }\n  /**\r\n   * Returns an array of listeners that are currently registered for the given\r\n   * event.\r\n   *\r\n   * @param {string} eventType - Name of the event to query\r\n   * @return {array}\r\n   */\n  ;\n\n  _proto.listeners = function listeners(eventType)\n  /* TODO: Array<EventSubscription> */\n  {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n\n    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n      return subscription.listener;\n    }) : [];\n  }\n  /**\r\n   * Emits an event of the given type with the given data. All handlers of that\r\n   * particular type will be notified.\r\n   *\r\n   * @param {string} eventType - Name of the event to emit\r\n   * @param {*} Arbitrary arguments to be passed to each registered listener\r\n   *\r\n   * @example\r\n   *   emitter.addListener('someEvent', function(message) {\r\n   *     console.log(message);\r\n   *   });\r\n   *\r\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\r\n   */\n  ;\n\n  _proto.emit = function emit(eventType) {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n\n    if (subscriptions) {\n      var keys = Object.keys(subscriptions);\n\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        var subscription = subscriptions[key]; // The subscription may have been removed during this event loop.\n\n        if (subscription) {\n          this._currentSubscription = subscription;\n\n          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n        }\n      }\n\n      this._currentSubscription = null;\n    }\n  }\n  /**\r\n   * Provides a hook to override how the emitter emits an event to a specific\r\n   * subscription. This allows you to set up logging and error boundaries\r\n   * specific to your environment.\r\n   *\r\n   * @param {EmitterSubscription} subscription\r\n   * @param {string} eventType\r\n   * @param {*} Arbitrary arguments to be passed to each registered listener\r\n   */\n  ;\n\n  _proto.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n    var args = Array.prototype.slice.call(arguments, 2);\n    subscription.listener.apply(subscription.context, args);\n  };\n\n  return BaseEventEmitter;\n}();\n\nmodule.exports = BaseEventEmitter;","/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule EventSubscription\r\n * @typechecks\r\n */\n'use strict';\n/**\r\n * EventSubscription represents a subscription to a particular event. It can\r\n * remove its own subscription.\r\n */\n\nvar EventSubscription = /*#__PURE__*/function () {\n  /**\r\n   * @param {EventSubscriptionVendor} subscriber the subscriber that controls\r\n   *   this subscription.\r\n   */\n  function EventSubscription(subscriber) {\n    this.subscriber = subscriber;\n  }\n  /**\r\n   * Removes this subscription from the subscriber that controls it.\r\n   */\n\n\n  var _proto = EventSubscription.prototype;\n\n  _proto.remove = function remove() {\n    if (this.subscriber) {\n      this.subscriber.removeSubscription(this);\n      this.subscriber = null;\n    }\n  };\n\n  return EventSubscription;\n}();\n\nmodule.exports = EventSubscription;","/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule EventSubscriptionVendor\r\n * @typechecks\r\n */\n'use strict';\n\nvar invariant = require(\"fbjs/lib/invariant\");\n/**\r\n * EventSubscriptionVendor stores a set of EventSubscriptions that are\r\n * subscribed to a particular event type.\r\n */\n\n\nvar EventSubscriptionVendor = /*#__PURE__*/function () {\n  function EventSubscriptionVendor() {\n    this._subscriptionsForType = {};\n    this._currentSubscription = null;\n  }\n  /**\r\n   * Adds a subscription keyed by an event type.\r\n   *\r\n   * @param {string} eventType\r\n   * @param {EventSubscription} subscription\r\n   */\n\n\n  var _proto = EventSubscriptionVendor.prototype;\n\n  _proto.addSubscription = function addSubscription(eventType, subscription) {\n    !(subscription.subscriber === this) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'The subscriber of the subscription is incorrectly set.') : invariant(false) : void 0;\n\n    if (!this._subscriptionsForType[eventType]) {\n      this._subscriptionsForType[eventType] = [];\n    }\n\n    var key = this._subscriptionsForType[eventType].length;\n\n    this._subscriptionsForType[eventType].push(subscription);\n\n    subscription.eventType = eventType;\n    subscription.key = key;\n    return subscription;\n  }\n  /**\r\n   * Removes a bulk set of the subscriptions.\r\n   *\r\n   * @param {?string} eventType - Optional name of the event type whose\r\n   *   registered supscriptions to remove, if null remove all subscriptions.\r\n   */\n  ;\n\n  _proto.removeAllSubscriptions = function removeAllSubscriptions(eventType) {\n    if (eventType === undefined) {\n      this._subscriptionsForType = {};\n    } else {\n      delete this._subscriptionsForType[eventType];\n    }\n  }\n  /**\r\n   * Removes a specific subscription. Instead of calling this function, call\r\n   * `subscription.remove()` directly.\r\n   *\r\n   * @param {object} subscription\r\n   */\n  ;\n\n  _proto.removeSubscription = function removeSubscription(subscription) {\n    var eventType = subscription.eventType;\n    var key = subscription.key;\n    var subscriptionsForType = this._subscriptionsForType[eventType];\n\n    if (subscriptionsForType) {\n      delete subscriptionsForType[key];\n    }\n  }\n  /**\r\n   * Returns the array of subscriptions that are currently registered for the\r\n   * given event type.\r\n   *\r\n   * Note: This array can be potentially sparse as subscriptions are deleted\r\n   * from it when they are removed.\r\n   *\r\n   * TODO: This returns a nullable array. wat?\r\n   *\r\n   * @param {string} eventType\r\n   * @return {?array}\r\n   */\n  ;\n\n  _proto.getSubscriptionsForType = function getSubscriptionsForType(eventType) {\n    return this._subscriptionsForType[eventType];\n  };\n\n  return EventSubscriptionVendor;\n}();\n\nmodule.exports = EventSubscriptionVendor;","\"use strict\";\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\n\n\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\n\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\n\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;","/* eslint no-console: 0 */\nimport { EventEmitter } from 'fbemitter';\n\n/**\n * Default regular emitter\n * @param {MessageEvent} e Original websocket event\n * @param {WsClientEvented} instance\n */\nconst defaultMessageHandler = (e, instance) => {\n  const data = JSON.parse(e.data);\n  const responseType = typeof data;\n\n  if (responseType === 'object' && data.type) {\n    instance.emitter.emit(data.type, e, data);\n  }\n};\n\n/**\n * WSClientEvented - WebSocket Client with event emission\n * @author Weblogixx (cs@weblogixx.de)\n *\n * @example let wsClient = new WsClientEvented('ws://localhost:123', 'example-protocol', {\n *   autoOpen: false\n * });\n *\n * Available options:\n * bool autoOpen [default: true] Automatically connect the websocket on initialisation?\n * bool autoReconnect [default: true] Automatically reconnect the websocket if connection is lost?\n * bool debug [default: false] Show debug output?\n * bool forceCloseOnReload [default: false] Send a forced close on browser reload? Only available when using the client in the main thread!\n * int reconnectInterval [default: 1000] Delay in ms for reconnect tries\n * float reconnectDecay [default 1.5] Factor for reconnects\n * int timeoutInterval [default: 2000] Time in ms to wait for connects\n * string binaryType [default: blob] Binary type for websocket transmission\n * string payloadItemName [default: payload] Send key for send items\n * int maxReconnects [default: null] Maximal amount of reconnects. Set to null for inifinite\n * int maxReconnectTimeout [default: 5000] Maximal amount of milliseconds to wait for reconnects\n * int maxSendTries [default: 10] Maximal amount of tries for ws send to fail for the same request\n * function onBeforeWsOpen [default: null] Called before WebSocket connections are established\n * function onWsOpen [default: null] Called when a WebSocket connection becomes ready\n * function onWsMessage [default: defaultMessageHandler] Called on all WebSocket onMessage events. Defaults to emitting via fbemitter\n * function onWsClose [default: null] Called when a WebSocket connection is closed\n * function onWsError [default: null] Called when a WebSocket connection throws errors\n * function onMaxReconnects [default: null] Called when the maximal amount of reconnects is reached\n * function onWsTimeout [default: null] Called when a WebSocket connection times out\n */\nexport default class WsClientEvented {\n\n  /**\n   * Create a new instance of WsClientEvent\n   * @param {String} url Url to connect to\n   * @param {String|Array} protocols List of protocols [optional]\n   * @param {Object} options Options to pass in [optional]\n   */\n  constructor(url, protocols = '', options = {}) {\n\n    // Instanciate a new event emitter\n    this.emitter = new EventEmitter();\n\n    this.url = url;\n    this.protocols = protocols && protocols.length > 0 ? protocols : null;\n\n    // How often did the websocket retry to connect?\n    this.reconnectAttempts = 0;\n\n    // Set to true to indicate no reconnect should take place\n    this.forcedClose = false;\n\n    // The websocket instance\n    this.ws = null;\n\n    // List of tries for each send request\n    this.sendTries = {};\n\n    // Default settings\n    this.settings = {\n      autoOpen: true,\n      autoReconnect: true,\n      debug: false,\n      forceCloseOnReload: false,\n      reconnectInterval: 1000,\n      reconnectDecay: 1.5,\n      timeoutInterval: 2000,\n      binaryType: 'blob',\n      payloadItemName: 'payload',\n      maxReconnects: null,\n      maxSendTries: 10,\n      maxReconnectTimeout: 5000,\n      onBeforeWsOpen: null,\n      onWsOpen: null,\n      onWsMessage: defaultMessageHandler.bind(this),\n      onWsClose: null,\n      onWsError: null,\n      onMaxReconnects: null,\n      onWsTimeout: null,\n    };\n\n    // Merge settings with defaults\n    Object.keys(options).forEach((option) => {\n      this.settings[option] = options[option];\n    });\n\n    // Attach all active listeners\n    ['onBeforeWsOpen', 'onWsOpen', 'onWsMessage', 'onWsClose', 'onWsError', 'onMaxReconnects', 'onWsTimeout'].forEach((userEvt) => {\n      if (typeof this.settings[userEvt] === 'function') {\n        this.emitter.addListener(userEvt, (evt) => {\n          this.settings[userEvt](evt, this);\n        });\n      }\n    });\n\n    if (this.settings.autoOpen) {\n      this.open();\n    }\n\n    if (this.settings.forceCloseOnReload) {\n      self.addEventListener('beforeunload', () => {\n        this.close();\n      });\n    }\n  }\n\n  /**\n   * Output debug information (only if debug setting enabled)\n   * @param  {String} msg Message to output\n   */\n  debug(msg) {\n    if (this.settings.debug) {\n      console.warn(msg);\n    }\n  }\n\n  /**\n   * Add a new event listener\n   * @param {String} evt Name of the event\n   * @param {Function} callback Function to attach\n   * @return {WsClientEvented}\n   */\n  addListener(evt, callback) {\n    this.emitter.addListener(evt, callback);\n    return this;\n  }\n\n  /**\n   * Removes all listeners with a given name\n   * @param  {String} evt\n   * @return {WsClientEvented}\n   */\n  removeListener(evt) {\n    this.emitter.removeAllListeners(evt);\n    return this;\n  }\n\n  /**\n   * Send a new request\n   * @param  {String} event Event to send\n   * @param  {Object|String} payload Data to send as payload [optional]\n   * @return {WsClientEvent}\n   */\n  send(type, payload = {}) {\n\n    // Skip if type is not given\n    if (!type) {\n      throw new Error(`Must provide an event type, provided: ${type}`);\n    }\n\n    // Only send if the connection is available.\n    if (!this.ws) {\n      if (this.settings.autoReconnect) {\n        this.open();\n      } else {\n        this.debug(`Tried to send event ${type}, but forced close was set. Please open the connection manually via #open!`);\n        return this;\n      }\n    }\n\n    // Add the item to the send try list\n    if (typeof this.sendTries[type] === 'undefined') {\n      this.sendTries[type] = 1;\n    }\n\n    this.debug(`Trying to send event ${type} for the ${this.sendTries[type]} time...`);\n\n    switch (this.ws.readyState) {\n\n      // If the socket is in connecting state, try it again in a couple of ms\n      case WebSocket.CONNECTING:\n\n        // Skip trying to send the request if we reached the maximum\n        if (this.sendTries[type] >= this.settings.maxSendTries) {\n          this.debug(`WS still in connecting state, giving up after ${this.settings.maxSendTries} tries for event ${type}`);\n          return this;\n        }\n\n        this.sendTries[type] += 1;\n        self.setTimeout(() => {\n          this.send(type, payload);\n        }, 500);\n        break;\n\n      // If the socket is getting closed or is closed, reopen it\n      case WebSocket.CLOSING:\n      case WebSocket.CLOSED:\n\n        // Skip trying to send the request if we reached the maximum\n        if (this.sendTries[type] >= this.settings.maxSendTries) {\n          this.debug(`WS still in closing state, giving up after ${this.settings.maxSendTries} tries for event ${type}`);\n          return this;\n        }\n\n        this.sendTries[type] += 1;\n        this.open(true);\n        self.setTimeout(() => {\n          this.send(type, payload);\n        }, 500);\n        break;\n\n      // If the websocket is open, just send\n      case WebSocket.OPEN:\n      default:\n\n        this.ws.send(JSON.stringify({\n          type,\n          [this.settings.payloadItemName]: payload,\n        }));\n\n        // Request went through, reset the try counter\n        this.sendTries[type] = 1;\n    }\n\n    return this;\n  }\n\n  /**\n   * Open the websocket\n   * @param {Boolean} reconnecting Status of the connection (true if a forced reconnect was done)\n   * @return {WsClientEvent}\n   */\n  open(reconnecting = false) {\n\n    // If the maximal amounts of reconnects is hit, just exit\n    if (this.settings.maxReconnects && this.reconnectAttempts >= this.settings.maxReconnects) {\n      this.debug('Maximal amount of reconnects reached, giving up! Please call #open by yourself to retry.');\n      this.emitter.emit('onMaxReconnects');\n      return this;\n    }\n\n    // Close the websocket if it is already open\n    if (!reconnecting && this.ws) {\n      this.close();\n    }\n\n    this.emitter.emit('onBeforeWsOpen');\n\n    // Automatically disconnect after a given period of time\n    const connectTimeOut = setTimeout(() => {\n      this.debug('WS Connection timed out');\n      this.emitter.emit('onWsTimeout');\n    }, this.settings.timeoutInterval);\n\n    // Create the new websocket instance\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.binaryType = this.settings.binaryType;\n\n    // Add the needed events\n    this.ws.addEventListener('open', (e) => {\n\n      // Clean up the connect timeout after open was fired\n      clearTimeout(connectTimeOut);\n\n      this.emitter.emit('onWsOpen', e, this);\n\n      this.debug(`WS connection successfully opened on attemp#${this.reconnectAttempts}.`);\n\n      // We are connected, so reset the reconnect attempts\n      this.reconnectAttempts = 0;\n\n      // Reset the send queue\n      this.sendTries = {};\n    });\n\n    this.ws.addEventListener('message', (e) => {\n      this.emitter.emit('onWsMessage', e, this);\n    });\n\n    this.ws.addEventListener('close', (e) => {\n\n      clearTimeout(connectTimeOut);\n\n      this.emitter.emit('onWsClose', e, this);\n\n      // Try to reconnect if the close action was not forced via WsClientEvented#close\n      if (!this.forcedClose && this.settings.autoReconnect) {\n\n        // Reconnect the websocket automatically\n        // @credits: https://github.com/joewalnes/reconnecting-websocket/\n        let timeout = this.settings.reconnectInterval * Math.pow(this.settings.reconnectDecay, this.reconnectAttempts);\n        if (timeout > this.settings.maxReconnectTimeout) {\n          timeout = this.settings.maxReconnectTimeout;\n        }\n        this.debug(`Auto reconnect required, trying again in ${timeout} ms...`);\n\n        setTimeout(() => {\n          this.reconnectAttempts += 1;\n          this.open(true);\n          this.debug('WS connection timed out, trying to reconnect...');\n        }, timeout);\n      } else if (this.forcedClose) {\n        this.forcedClose = false;\n        this.debug('WS forced closing the connection');\n      }\n    });\n\n    this.ws.addEventListener('error', (e) => {\n      this.emitter.emit('onWsError', e, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * Close the websocket if it is open\n   * @param  {Number} code The code to send [optional]\n   * @param  {String} reason The reason for closing [optional]\n   * @return {WsClientEvent}\n   */\n  close(code = 1000, reason = '') {\n    if (this.ws) {\n      this.forcedClose = true;\n      this.reconnectAttempts = 0;\n      this.sendTries = {};\n      this.ws.close(code, reason);\n      this.ws = null;\n    }\n    return this;\n  }\n}\n","import WsClientEvented from './index';\n\nwindow.WsClientEvented = WsClientEvented;\n"],"sourceRoot":""}