{"version":3,"sources":["webpack:///index.js","webpack:///webpack/bootstrap 8163dd1ef139ee8d2712?9ce0","webpack:///./~/fbjs/lib/invariant.js?4599","webpack:///./lib/index.js?bdd8","webpack:///./~/fbemitter/index.js?490b","webpack:///./~/fbemitter/lib/BaseEventEmitter.js?e0d9","webpack:///./~/fbemitter/lib/EmitterSubscription.js?44c5","webpack:///./~/fbemitter/lib/EventSubscription.js?3696","webpack:///./~/fbemitter/lib/EventSubscriptionVendor.js?6d33","webpack:///./~/fbjs/lib/emptyFunction.js?2a3b"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","invariant","condition","format","a","b","d","e","f","error","undefined","Error","args","argIndex","replace","framesToPop","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_fbemitter","WsClientEvented","url","_this","this","protocols","arguments","options","emitter","EventEmitter","reconnectAttempts","forcedClose","ws","sendTries","settings","autoOpen","autoReconnect","debug","reconnectInterval","reconnectDecay","timeoutInterval","binaryType","maxReconnects","maxSendTries","maxReconnectTimeout","onBeforeWsOpen","onWsOpen","onWsMessage","onWsClose","onWsError","onWsTimeout","_arr","_loop","_i","addListener","evt","data","JSON","parse","responseType","type","emit","open","msg","console","warn","callback","removeAllListeners","payload","_this2","readyState","WebSocket","CONNECTING","window","setTimeout","send","CLOSING","CLOSED","OPEN","stringify","_this3","reconnecting","close","connectTimeOut","addEventListener","clearTimeout","timeout","Math","pow","code","reason","fbemitter","EmitterSubscription","EventSubscriptionVendor","emptyFunction","BaseEventEmitter","_subscriber","_currentSubscription","eventType","listener","context","addSubscription","once","removeCurrentListener","apply","removeAllSubscriptions","removeSubscription","listeners","subscriptions","getSubscriptionsForType","filter","thatReturnsTrue","map","subscription","keys","ii","__emitToSubscription","concat","Array","slice","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","EventSubscription","_EventSubscription","subscriber","remove","_subscriptionsForType","push","subscriptionsForType","makeEmptyFunction","arg","thatReturns","thatReturnsFalse","thatReturnsNull","thatReturnsThis","thatReturnsArgument"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GAE/BI,EAAOD,QAAUH,EAAoB,IAKhC,SAASI,EAAQD,EAASH,GExChC,YAaA,IAAAW,GAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAN,EAAAO,EAAAC,EAAAC,GAOA,IAAAN,EAAA,CACA,GAAAO,EACA,IAAAC,SAAAP,EACAM,EAAA,GAAAE,OAAA,qIACK,CACL,GAAAC,IAAAR,EAAAC,EAAAN,EAAAO,EAAAC,EAAAC,GACAK,EAAA,CACAJ,GAAA,GAAAE,OAAA,wBAAAR,EAAAW,QAAA,iBACA,MAAAF,GAAAC,QAKA,KADAJ,GAAAM,YAAA,EACAN,GAIAf,GAAAD,QAAAQ,GFyDM,SAASP,EAAQD,EAASH,GAE/B,YAQA,SAAS0B,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhHC,OAAOC,eAAe5B,EAAS,cAC7B6B,OAAO,GAGT,IAAIC,GAAe,WAAe,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMZ,OAAOC,eAAeI,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUX,EAAagB,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBN,EAAYkB,UAAWF,GAAiBC,GAAaX,EAAiBN,EAAaiB,GAAqBjB,MAI7hBmB,EAAa/C,EGrHW,GA4BvBgD,EAAe,WAQR,QARPA,GAQQC,GHwHT,GAAIC,GAAQC,KGxHEC,EAASC,UAAAf,QAAA,GAAAlB,SAAAiC,UAAA,GAAC,GAAEA,UAAA,GAAEC,EAAOD,UAAAf,QAAA,GAAAlB,SAAAiC,UAAA,MAAGA,UAAA,EH6HtC3B,GAAgByB,KGrIfH,GAWFG,KAAKI,QAAU,GAAAR,GAAAS,aAEfL,KAAKF,IAAMA,EACXE,KAAKC,UAAYA,GAAaA,EAAUd,OAAS,EAAIc,EAAY,KAGjED,KAAKM,kBAAoB,EAGzBN,KAAKO,aAAc,EAGnBP,KAAKQ,GAAK,KAGVR,KAAKS,aAGLT,KAAKU,UACHC,UAAU,EACVC,eAAe,EACfC,OAAO,EACPC,kBAAmB,IACnBC,eAAgB,IAChBC,gBAAiB,IACjBC,WAAY,OACZC,cAAe,KACfC,aAAc,GACdC,oBAAqB,IACrBC,eAAgB,KAChBC,SAAU,KACVC,YAAa,KACbC,UAAW,KACXC,UAAW,KACXC,YAAa,KAIf,KAAI,GAAIlC,KAAOW,GACbH,KAAKU,SAASlB,GAAOW,EAAQX,EAI/B,QH6HKmC,IG7HU,iBAAkB,WAAY,cAAe,YAAa,YAAa,eH+HjFC,EAAQ,WG/HT,GAAI9D,GAAC6D,EAAAE,EACwB,mBAArB9B,GAAKW,SAAS5C,IACtBiC,EAAKK,QAAQ0B,YAAYhE,EAAG,SAACiE,GAC3BhC,EAAKW,SAAS5C,GAAGiE,EAAGhC,MAH1B8B,EAAA,EAAAA,EAAAF,EAAAxC,OAAA0C,IHyIGD,GG/HH5B,MAAKI,QAAQ0B,YAAY,cAAe,SAAChE,GACvC,GAAIkE,GAAOC,KAAKC,MAAMpE,EAAEkE,MACpBG,QAAsBH,EAEN,YAAjBG,GAA6BH,EAAKI,MACnCrC,EAAKK,QAAQiC,KAAKL,EAAKI,KAAMtE,EAAGkE,KAIjChC,KAAKU,SAASC,UACfX,KAAKsC,OHwXR,MA3OAxD,GGvNGe,IHwNDL,IAAK,QACLX,MGvIE,SAAC0D,GACDvC,KAAKU,SAASG,OACf2B,QAAQC,KAAKF,MHkJd/C,IAAK,cACLX,MGzIQ,SAACkD,EAAKW,GAEf,MADA1C,MAAKI,QAAQ0B,YAAYC,EAAKW,GACvB1C,QHkJNR,IAAK,iBACLX,MG3IW,SAACkD,GAEb,MADA/B,MAAKI,QAAQuC,mBAAmBZ,GACzB/B,QHqJNR,IAAK,OACLX,MG7IC,SAACuD,EAAMQ,GH8IN,GAAIC,GAAS7C,IG3IhB,KAAIoC,EACF,8CAA+CA,CAIjD,KAAIpC,KAAKQ,GAAI,CACX,IAAGR,KAAKU,SAASE,cAIf,MADAZ,MAAKa,MAAK,uBAAwBuB,EAAI,8EAC/BpC,IAHPA,MAAKsC,OAmBT,OAXIM,IACFA,MAIiC,mBAAzB5C,MAAKS,UAAU2B,KACvBpC,KAAKS,UAAU2B,GAAQ,GAGzBpC,KAAKa,MAAK,wBAAyBuB,EAAI,YAAYpC,KAAKS,UAAU2B,GAAK,YAEhEpC,KAAKQ,GAAGsC,YAGb,IAAKC,WAAUC,WAGb,GAAGhD,KAAKS,UAAU2B,IAASpC,KAAKU,SAASS,aAEvC,MADAnB,MAAKa,MAAK,iDAAkDb,KAAKU,SAASS,aAAY,oBAAoBiB,GACnGpC,IAGTA,MAAKS,UAAU2B,KACfa,OAAOC,WAAW,WAChBL,EAAKM,KAAKf,EAAMQ,IACf,IACH,MAGF,KAAKG,WAAUK,QACf,IAAKL,WAAUM,OAGb,GAAGrD,KAAKS,UAAU2B,IAASpC,KAAKU,SAASS,aAEvC,MADAnB,MAAKa,MAAK,8CAA+Cb,KAAKU,SAASS,aAAY,oBAAoBiB,GAChGpC,IAGTA,MAAKS,UAAU2B,KACfpC,KAAKsC,MAAK,GACVW,OAAOC,WAAW,WAChBL,EAAKM,KAAKf,EAAMQ,IACf,IACH,MAGF,KAAKG,WAAUO,KACf,QAEEtD,KAAKQ,GAAG2C,KAAKlB,KAAKsB,WAChBnB,KAAMA,EACNQ,QAASA,KAIX5C,KAAKS,UAAU2B,GAAQ,EAG3B,MAAOpC,SHuJNR,IAAK,OACLX,MGhJC,WHiJC,GAAI2E,GAASxD,KGjJbyD,EAAYvD,UAAAf,QAAA,GAAAlB,SAAAiC,UAAA,IAAC,EAAKA,UAAA,EAGrB,IAAGF,KAAKU,SAASQ,eAAiBlB,KAAKM,mBAAqBN,KAAKU,SAASQ,cAExE,MADAlB,MAAKa,MAAM,4FACJb,MAILyD,GAAgBzD,KAAKQ,IACvBR,KAAK0D,QAGP1D,KAAKI,QAAQiC,KAAK,iBAGlB,IAAIsB,GAAiBT,WAAW,WAC9BM,EAAK3C,MAAM,2BACX2C,EAAKpD,QAAQiC,KAAK,gBACjBrC,KAAKU,SAASM,gBA2DjB,OAxDAhB,MAAKQ,GAAK,GAAIuC,WAAU/C,KAAKF,IAAKE,KAAKC,WACvCD,KAAKQ,GAAGS,WAAajB,KAAKU,SAASO,WAGnCjB,KAAKQ,GAAGoD,iBAAiB,OAAQ,SAAC9F,GAGhC+F,aAAaF,GAEbH,EAAKpD,QAAQiC,KAAK,WAAYvE,EAAC0F,GAE/BA,EAAK3C,MAAK,+CAAgD2C,EAAKlD,kBAAiB,KAGhFkD,EAAKlD,kBAAoB,EAGzBkD,EAAK/C,eAGPT,KAAKQ,GAAGoD,iBAAiB,UAAW,SAAC9F,GACnC0F,EAAKpD,QAAQiC,KAAK,cAAevE,EAAC0F,KAGpCxD,KAAKQ,GAAGoD,iBAAiB,QAAS,SAAC9F,GAOjC,GALA+F,aAAaF,GAEbH,EAAKpD,QAAQiC,KAAK,YAAavE,EAAC0F,IAG5BA,EAAKjD,aAAeiD,EAAK9C,SAASE,cAAe,CAInD,GAAIkD,GAAUN,EAAK9C,SAASI,kBAAoBiD,KAAKC,IAAIR,EAAK9C,SAASK,eAAgByC,EAAKlD,kBACzFwD,GAAUN,EAAK9C,SAASU,sBACzB0C,EAAUN,EAAK9C,SAASU,qBAE1BoC,EAAK3C,MAAK,4CAA6CiD,EAAO,UAE9DZ,WAAW,WACTM,EAAKlD,oBACLkD,EAAKlB,MAAK,GACVkB,EAAK3C,MAAM,oDACViD,OACKN,GAAKjD,cACbiD,EAAKjD,aAAc,EACnBiD,EAAK3C,MAAM,uCAIfb,KAAKQ,GAAGoD,iBAAiB,QAAS,SAAC9F,GACjC0F,EAAKpD,QAAQiC,KAAK,YAAavE,EAAC0F,KAG3BxD,QH6JNR,IAAK,QACLX,MGrJE,WHsJA,GGtJCoF,GAAI/D,UAAAf,QAAA,GAAAlB,SAAAiC,UAAA,GAAC,IAAIA,UAAA,GAAEgE,EAAMhE,UAAAf,QAAA,GAAAlB,SAAAiC,UAAA,GAAC,GAAEA,UAAA,EAQxB,OAPGF,MAAKQ,KACNR,KAAKO,aAAc,EACnBP,KAAKM,kBAAoB,EACzBN,KAAKS,aACLT,KAAKQ,GAAGkD,MAAMO,EAAMC,GACpBlE,KAAKQ,GAAK,MAELR,SAtSLH,IHqcL7C,GAAQ,WG3JM6C,EH4Jd5C,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,EAASH,GI7dhC,GAAAsH,IACA9D,aAAAxD,EAAA,GAGAI,GAAAD,QAAAmH,GJ6eM,SAASlH,EAAQD,EAASH,GK9ehC,YAEA,SAAA0B,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAE3F,GAAA0F,GAAAvH,EAAA,GACAwH,EAAAxH,EAAA,GAEAyH,EAAAzH,EAAA,GACAW,EAAAX,EAAA,GAgBA0H,EAAA,WAKA,QAAAA,KACAhG,EAAAyB,KAAAuE,GAEAvE,KAAAwE,YAAA,GAAAH,GACArE,KAAAyE,qBAAA,KA8IA,MA5HAF,GAAA5E,UAAAmC,YAAA,SAAA4C,EAAAC,EAAAC,GACA,MAAA5E,MAAAwE,YAAAK,gBAAAH,EAAA,GAAAN,GAAApE,KAAAwE,YAAAG,EAAAC,KAcAL,EAAA5E,UAAAmF,KAAA,SAAAJ,EAAAC,EAAAC,GACA,GAAAxE,GAAAJ,IACA,OAAAA,MAAA8B,YAAA4C,EAAA,WACAtE,EAAA2E,wBACAJ,EAAAK,MAAAJ,EAAA1E,cAYAqE,EAAA5E,UAAAgD,mBAAA,SAAA+B,GACA1E,KAAAwE,YAAAS,uBAAAP,IAyBAH,EAAA5E,UAAAoF,sBAAA,WACA/E,KAAAyE,qBAAsHxG,OAAAT,GAAA,GACtHwC,KAAAwE,YAAAU,mBAAAlF,KAAAyE,uBAWAF,EAAA5E,UAAAwF,UAAA,SAAAT,GACA,GAAAU,GAAApF,KAAAwE,YAAAa,wBAAAX,EACA,OAAAU,KAAAE,OAAAhB,EAAAiB,iBAAAC,IAAA,SAAAC,GACA,MAAAA,GAAAd,eAmBAJ,EAAA5E,UAAA0C,KAAA,SAAAqC,GACA,GAAAU,GAAApF,KAAAwE,YAAAa,wBAAAX,EACA,IAAAU,EAAA,CAEA,OADAM,GAAA/G,OAAA+G,KAAAN,GACAO,EAAA,EAAsBA,EAAAD,EAAAvG,OAAkBwG,IAAA,CACxC,GAAAnG,GAAAkG,EAAAC,GACAF,EAAAL,EAAA5F,EAEAiG,KACAzF,KAAAyE,qBAAAgB,EACAzF,KAAA4F,qBAAAZ,MAAAhF,MAAAyF,GAAAI,OAAAC,MAAAnG,UAAAoG,MAAA3I,KAAA8C,cAGAF,KAAAyE,qBAAA,OAcAF,EAAA5E,UAAAiG,qBAAA,SAAAH,EAAAf,GACA,GAAAvG,GAAA2H,MAAAnG,UAAAoG,MAAA3I,KAAA8C,UAAA,EACAuF,GAAAd,SAAAK,MAAAS,EAAAb,QAAAzG,IAGAoG,IAGAtH,GAAAD,QAAAuH,GLggBM,SAAStH,EAAQD,EAASH,GMlrBhC,YAEA,SAAA0B,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAE3F,QAAAsH,GAAAC,EAAAC,GAA0C,qBAAAA,IAAA,OAAAA,EAA+D,SAAAxH,WAAA,iEAAAwH,GAAuGD,GAAAtG,UAAAhB,OAAAwH,OAAAD,KAAAvG,WAAyEyG,aAAevH,MAAAoH,EAAA5G,YAAA,EAAAE,UAAA,EAAAD,cAAA,KAA6E4G,IAAAvH,OAAA0H,eAAA1H,OAAA0H,eAAAJ,EAAAC,GAAAD,EAAAK,UAAAJ,GAErX,GAAAK,GAAA1J,EAAA,GAMAuH,EAAA,SAAAoC,GAYA,QAAApC,GAAAqC,EAAA9B,EAAAC,GACArG,EAAAyB,KAAAoE,GAEAoC,EAAApJ,KAAA4C,KAAAyG,GACAzG,KAAA2E,WACA3E,KAAA4E,UAGA,MAnBAoB,GAAA5B,EAAAoC,GAmBApC,GACCmC,EAEDtJ,GAAAD,QAAAoH,GNosBM,SAASnH,EAAQD,GOvuBvB,YAOA,SAAAuB,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAE3F,GAAA6H,GAAA,WAOA,QAAAA,GAAAE,GACAlI,EAAAyB,KAAAuG,GAEAvG,KAAAyG,aAWA,MAJAF,GAAA5G,UAAA+G,OAAA,WACA1G,KAAAyG,WAAAvB,mBAAAlF,OAGAuG,IAGAtJ,GAAAD,QAAAuJ,GPyvBM,SAAStJ,EAAQD,EAASH,GQ1xBhC,YAEA,SAAA0B,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAE3F,GAAAlB,GAAAX,EAAA,GAOAwH,EAAA,WACA,QAAAA,KACA9F,EAAAyB,KAAAqE,GAEArE,KAAA2G,yBACA3G,KAAAyE,qBAAA,KAuEA,MA7DAJ,GAAA1E,UAAAkF,gBAAA,SAAAH,EAAAe,GACAA,EAAAgB,aAAAzG,KAAAxC,GAAA,GAAAS,OACA+B,KAAA2G,sBAAAjC,KACA1E,KAAA2G,sBAAAjC,MAEA,IAAAlF,GAAAQ,KAAA2G,sBAAAjC,GAAAvF,MAIA,OAHAa,MAAA2G,sBAAAjC,GAAAkC,KAAAnB,GACAA,EAAAf,YACAe,EAAAjG,MACAiG,GAUApB,EAAA1E,UAAAsF,uBAAA,SAAAP,GACAzG,SAAAyG,EACA1E,KAAA2G,+BAEA3G,MAAA2G,sBAAAjC,IAWAL,EAAA1E,UAAAuF,mBAAA,SAAAO,GACA,GAAAf,GAAAe,EAAAf,UACAlF,EAAAiG,EAAAjG,IAEAqH,EAAA7G,KAAA2G,sBAAAjC,EACAmC,UACAA,GAAArH,IAiBA6E,EAAA1E,UAAA0F,wBAAA,SAAAX,GACA,MAAA1E,MAAA2G,sBAAAjC,IAGAL,IAGApH,GAAAD,QAAAqH,GR4yBM,SAASpH,EAAQD,GSv4BvB,YAEA,SAAA8J,GAAAC,GACA,kBACA,MAAAA,IASA,QAAAzC,MAEAA,EAAA0C,YAAAF,EACAxC,EAAA2C,iBAAAH,GAAA,GACAxC,EAAAiB,gBAAAuB,GAAA,GACAxC,EAAA4C,gBAAAJ,EAAA,MACAxC,EAAA6C,gBAAA,WACA,MAAAnH,OAEAsE,EAAA8C,oBAAA,SAAAL,GACA,MAAAA,IAGA9J,EAAAD,QAAAsH","file":"index.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2013-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @providesModule invariant\n\t */\n\t\n\t\"use strict\";\n\t\n\t/**\n\t * Use invariant() to assert state which your program assumes to be true.\n\t *\n\t * Provide sprintf-style format (only %s is supported) and arguments\n\t * to provide information about what broke and what you were\n\t * expecting.\n\t *\n\t * The invariant message will be stripped in production, but the invariant\n\t * will remain to ensure logic does not differ in production.\n\t */\n\t\n\tvar invariant = function (condition, format, a, b, c, d, e, f) {\n\t  if (false) {\n\t    if (format === undefined) {\n\t      throw new Error('invariant requires an error message argument');\n\t    }\n\t  }\n\t\n\t  if (!condition) {\n\t    var error;\n\t    if (format === undefined) {\n\t      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n\t    } else {\n\t      var args = [a, b, c, d, e, f];\n\t      var argIndex = 0;\n\t      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {\n\t        return args[argIndex++];\n\t      }));\n\t    }\n\t\n\t    error.framesToPop = 1; // we don't care about invariant's own frame\n\t    throw error;\n\t  }\n\t};\n\t\n\tmodule.exports = invariant;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _fbemitter = __webpack_require__(3);\n\t\n\t/**\n\t * WSClientEvented - WebSocket Client with event emission\n\t * @author Weblogixx (cs@weblogixx.de)\n\t *\n\t * @example let wsClient = new WsClientEvented('ws://localhost:123', 'example-protocol', {\n\t *   autoOpen: false\n\t * });\n\t *\n\t * Available options:\n\t * bool autoOpen [default: true] Automatically connect the websocket on initialisation?\n\t * bool autoReconnect [default: true] Automatically reconnect the websocket if connection is lost?\n\t * bool debug [default: false] Show debug output?\n\t * int reconnectInterval [default: 1000] Delay in ms for reconnect tries\n\t * float reconnectDecay [default 1.5] Factor for reconnects\n\t * int timeoutInterval [default: 2000] Time in ms to wait for connects\n\t * string binaryType [default: blob] Binary type for websocket transmission\n\t * int maxReconnects [default: null] Maximal amount of reconnects. Set to null for inifinite\n\t * int maxReconnectTimeout [default: 5000] Maximal amount of milliseconds to wait for reconnects\n\t * int maxSendTries [default: 10] Maximal amount of tries for ws send to fail for the same request\n\t * function onBeforeWsOpen [default: null] Called before WebSocket connections are established\n\t * function onWsOpen [default: null] Called when a WebSocket connection becomes ready\n\t * function onWsMessage [default: null] Called on all WebSocket onMessage events\n\t * function onWsClose [default: null] Called when a WebSocket connection is closed\n\t * function onWsError [default: null] Called when a WebSocket connection throws errors\n\t * function onWsTimeout [default: null] Called when a WebSocket connection times out\n\t */\n\t\n\tvar WsClientEvented = (function () {\n\t\n\t  /**\n\t   * Create a new instance of WsClientEvent\n\t   * @param {String} url Url to connect to\n\t   * @param {String|Array} protocols List of protocols [optional]\n\t   * @param {Object} options Options to pass in [optional]\n\t   */\n\t\n\t  function WsClientEvented(url) {\n\t    var _this = this;\n\t\n\t    var protocols = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\t    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t    _classCallCheck(this, WsClientEvented);\n\t\n\t    // Instanciate a new event emitter\n\t    this.emitter = new _fbemitter.EventEmitter();\n\t\n\t    this.url = url;\n\t    this.protocols = protocols && protocols.length > 0 ? protocols : null;\n\t\n\t    // How often did the websocket retry to connect?\n\t    this.reconnectAttempts = 0;\n\t\n\t    // Set to true to indicate no reconnect should take place\n\t    this.forcedClose = false;\n\t\n\t    // The websocket instance\n\t    this.ws = null;\n\t\n\t    // List of tries for each send request\n\t    this.sendTries = {};\n\t\n\t    // Default settings\n\t    this.settings = {\n\t      autoOpen: true,\n\t      autoReconnect: true,\n\t      debug: false,\n\t      reconnectInterval: 1000,\n\t      reconnectDecay: 1.5,\n\t      timeoutInterval: 2000,\n\t      binaryType: 'blob',\n\t      maxReconnects: null,\n\t      maxSendTries: 10,\n\t      maxReconnectTimeout: 5000,\n\t      onBeforeWsOpen: null,\n\t      onWsOpen: null,\n\t      onWsMessage: null,\n\t      onWsClose: null,\n\t      onWsError: null,\n\t      onWsTimeout: null\n\t    };\n\t\n\t    // Merge settings with defaults\n\t    for (var key in options) {\n\t      this.settings[key] = options[key];\n\t    }\n\t\n\t    // Attach all active listeners\n\t    var _arr = ['onBeforeWsOpen', 'onWsOpen', 'onWsMessage', 'onWsClose', 'onWsError', 'onWsTimeout'];\n\t\n\t    var _loop = function () {\n\t      var e = _arr[_i];\n\t      if (typeof _this.settings[e] === 'function') {\n\t        _this.emitter.addListener(e, function (evt) {\n\t          _this.settings[e](evt, _this);\n\t        });\n\t      }\n\t    };\n\t\n\t    for (var _i = 0; _i < _arr.length; _i++) {\n\t      _loop();\n\t    }\n\t\n\t    // Handle websocket requests that come back in the required format.\n\t    // @todo: Add support for binary\n\t    this.emitter.addListener('onWsMessage', function (e) {\n\t      var data = JSON.parse(e.data);\n\t      var responseType = typeof data;\n\t\n\t      if (responseType === 'object' && data.type) {\n\t        _this.emitter.emit(data.type, e, data);\n\t      }\n\t    });\n\t\n\t    if (this.settings.autoOpen) {\n\t      this.open();\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Output debug information (only if debug setting enabled)\n\t   * @param  {String} msg Message to output\n\t   */\n\t\n\t  _createClass(WsClientEvented, [{\n\t    key: 'debug',\n\t    value: function debug(msg) {\n\t      if (this.settings.debug) {\n\t        console.warn(msg);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Add a new event listener\n\t     * @param {String} evt Name of the event\n\t     * @param {Function} callback Function to attach\n\t     * @return {WsClientEvented}\n\t     */\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(evt, callback) {\n\t      this.emitter.addListener(evt, callback);\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Removes all listeners with a given name\n\t     * @param  {String} evt\n\t     * @return {WsClientEvented}\n\t     */\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(evt) {\n\t      this.emitter.removeAllListeners(evt);\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Send a new request\n\t     * @param  {String} event Event to send\n\t     * @param  {Object|String} payload Data to send as payload [optional]\n\t     * @return {WsClientEvent}\n\t     */\n\t  }, {\n\t    key: 'send',\n\t    value: function send(type, payload) {\n\t      var _this2 = this;\n\t\n\t      // Skip if type is not given\n\t      if (!type) {\n\t        throw 'Must provide an event type, provided: ' + type;\n\t      }\n\t\n\t      // Only send if the connection is available.\n\t      if (!this.ws) {\n\t        if (this.settings.autoReconnect) {\n\t          this.open();\n\t        } else {\n\t          this.debug('Tried to send event ' + type + ', but forced close was set. Please open the connection manually via #open!');\n\t          return this;\n\t        }\n\t      }\n\t\n\t      // Allow to send an empty payload\n\t      if (!payload) {\n\t        payload = {};\n\t      }\n\t\n\t      // Add the item to the send try list\n\t      if (typeof this.sendTries[type] === 'undefined') {\n\t        this.sendTries[type] = 1;\n\t      }\n\t\n\t      this.debug('Trying to send event ' + type + ' for the ' + this.sendTries[type] + ' time...');\n\t\n\t      switch (this.ws.readyState) {\n\t\n\t        // If the socket is in connecting state, try it again in a couple of ms\n\t        case WebSocket.CONNECTING:\n\t\n\t          // Skip trying to send the request if we reached the maximum\n\t          if (this.sendTries[type] >= this.settings.maxSendTries) {\n\t            this.debug('WS still in connecting state, giving up after ' + this.settings.maxSendTries + ' tries for event ' + type);\n\t            return this;\n\t          }\n\t\n\t          this.sendTries[type]++;\n\t          window.setTimeout(function () {\n\t            _this2.send(type, payload);\n\t          }, 500);\n\t          break;\n\t\n\t        // If the socket is getting closed or is closed, reopen it\n\t        case WebSocket.CLOSING:\n\t        case WebSocket.CLOSED:\n\t\n\t          // Skip trying to send the request if we reached the maximum\n\t          if (this.sendTries[type] >= this.settings.maxSendTries) {\n\t            this.debug('WS still in closing state, giving up after ' + this.settings.maxSendTries + ' tries for event ' + type);\n\t            return this;\n\t          }\n\t\n\t          this.sendTries[type]++;\n\t          this.open(true);\n\t          window.setTimeout(function () {\n\t            _this2.send(type, payload);\n\t          }, 500);\n\t          break;\n\t\n\t        // If the websocket is open, just send\n\t        case WebSocket.OPEN:\n\t        default:\n\t\n\t          this.ws.send(JSON.stringify({\n\t            type: type,\n\t            payload: payload\n\t          }));\n\t\n\t          // Request went through, reset the try counter\n\t          this.sendTries[type] = 1;\n\t      }\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Open the websocket\n\t     * @param {Boolean} reconnecting Status of the connection (true if a forced reconnect was done)\n\t     * @return {WsClientEvent}\n\t     */\n\t  }, {\n\t    key: 'open',\n\t    value: function open() {\n\t      var _this3 = this;\n\t\n\t      var reconnecting = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\t\n\t      // If the maximal amounts of reconnects is hit, just exit\n\t      if (this.settings.maxReconnects && this.reconnectAttempts >= this.settings.maxReconnects) {\n\t        this.debug('Maximal amount of reconnects reached, giving up! Please call #open by yourself to retry.');\n\t        return this;\n\t      }\n\t\n\t      // Close the websocket if it is already open\n\t      if (!reconnecting && this.ws) {\n\t        this.close();\n\t      }\n\t\n\t      this.emitter.emit('onBeforeWsOpen');\n\t\n\t      // Automatically disconnect after a given period of time\n\t      var connectTimeOut = setTimeout(function () {\n\t        _this3.debug('WS Connection timed out');\n\t        _this3.emitter.emit('onWsTimeout');\n\t      }, this.settings.timeoutInterval);\n\t\n\t      // Create the new websocket instance\n\t      this.ws = new WebSocket(this.url, this.protocols);\n\t      this.ws.binaryType = this.settings.binaryType;\n\t\n\t      // Add the needed events\n\t      this.ws.addEventListener('open', function (e) {\n\t\n\t        // Clean up the connect timeout after open was fired\n\t        clearTimeout(connectTimeOut);\n\t\n\t        _this3.emitter.emit('onWsOpen', e, _this3);\n\t\n\t        _this3.debug('WS connection successfully opened on attemp#' + _this3.reconnectAttempts + '.');\n\t\n\t        // We are connected, so reset the reconnect attempts\n\t        _this3.reconnectAttempts = 0;\n\t\n\t        // Reset the send queue\n\t        _this3.sendTries = {};\n\t      });\n\t\n\t      this.ws.addEventListener('message', function (e) {\n\t        _this3.emitter.emit('onWsMessage', e, _this3);\n\t      });\n\t\n\t      this.ws.addEventListener('close', function (e) {\n\t\n\t        clearTimeout(connectTimeOut);\n\t\n\t        _this3.emitter.emit('onWsClose', e, _this3);\n\t\n\t        // Try to reconnect if the close action was not forced via WsClientEvented#close\n\t        if (!_this3.forcedClose && _this3.settings.autoReconnect) {\n\t\n\t          // Reconnect the websocket automatically\n\t          // @credits: https://github.com/joewalnes/reconnecting-websocket/\n\t          var timeout = _this3.settings.reconnectInterval * Math.pow(_this3.settings.reconnectDecay, _this3.reconnectAttempts);\n\t          if (timeout > _this3.settings.maxReconnectTimeout) {\n\t            timeout = _this3.settings.maxReconnectTimeout;\n\t          }\n\t          _this3.debug('Auto reconnect required, trying again in ' + timeout + ' ms...');\n\t\n\t          setTimeout(function () {\n\t            _this3.reconnectAttempts++;\n\t            _this3.open(true);\n\t            _this3.debug('WS connection timed out, trying to reconnect...');\n\t          }, timeout);\n\t        } else if (_this3.forcedClose) {\n\t          _this3.forcedClose = false;\n\t          _this3.debug('WS forced closing the connection');\n\t        }\n\t      });\n\t\n\t      this.ws.addEventListener('error', function (e) {\n\t        _this3.emitter.emit('onWsError', e, _this3);\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Close the websocket if it is open\n\t     * @param  {Number} code The code to send [optional]\n\t     * @param  {String} reason The reason for closing [optional]\n\t     * @return {WsClientEvent}\n\t     */\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      var code = arguments.length <= 0 || arguments[0] === undefined ? 1000 : arguments[0];\n\t      var reason = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\t\n\t      if (this.ws) {\n\t        this.forcedClose = true;\n\t        this.reconnectAttempts = 0;\n\t        this.sendTries = {};\n\t        this.ws.close(code, reason);\n\t        this.ws = null;\n\t      }\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return WsClientEvented;\n\t})();\n\t\n\texports['default'] = WsClientEvented;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\tvar fbemitter = {\n\t  EventEmitter: __webpack_require__(4)\n\t};\n\t\n\tmodule.exports = fbemitter;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @providesModule BaseEventEmitter\n\t * @typechecks\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar EmitterSubscription = __webpack_require__(5);\n\tvar EventSubscriptionVendor = __webpack_require__(7);\n\t\n\tvar emptyFunction = __webpack_require__(8);\n\tvar invariant = __webpack_require__(1);\n\t\n\t/**\n\t * @class BaseEventEmitter\n\t * @description\n\t * An EventEmitter is responsible for managing a set of listeners and publishing\n\t * events to them when it is told that such events happened. In addition to the\n\t * data for the given event it also sends a event control object which allows\n\t * the listeners/handlers to prevent the default behavior of the given event.\n\t *\n\t * The emitter is designed to be generic enough to support all the different\n\t * contexts in which one might want to emit events. It is a simple multicast\n\t * mechanism on top of which extra functionality can be composed. For example, a\n\t * more advanced emitter may use an EventHolder and EventFactory.\n\t */\n\t\n\tvar BaseEventEmitter = (function () {\n\t  /**\n\t   * @constructor\n\t   */\n\t\n\t  function BaseEventEmitter() {\n\t    _classCallCheck(this, BaseEventEmitter);\n\t\n\t    this._subscriber = new EventSubscriptionVendor();\n\t    this._currentSubscription = null;\n\t  }\n\t\n\t  /**\n\t   * Adds a listener to be invoked when events of the specified type are\n\t   * emitted. An optional calling context may be provided. The data arguments\n\t   * emitted will be passed to the listener function.\n\t   *\n\t   * TODO: Annotate the listener arg's type. This is tricky because listeners\n\t   *       can be invoked with varargs.\n\t   *\n\t   * @param {string} eventType - Name of the event to listen to\n\t   * @param {function} listener - Function to invoke when the specified event is\n\t   *   emitted\n\t   * @param {*} context - Optional context object to use when invoking the\n\t   *   listener\n\t   */\n\t\n\t  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\n\t    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n\t  };\n\t\n\t  /**\n\t   * Similar to addListener, except that the listener is removed after it is\n\t   * invoked once.\n\t   *\n\t   * @param {string} eventType - Name of the event to listen to\n\t   * @param {function} listener - Function to invoke only once when the\n\t   *   specified event is emitted\n\t   * @param {*} context - Optional context object to use when invoking the\n\t   *   listener\n\t   */\n\t\n\t  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\n\t    var emitter = this;\n\t    return this.addListener(eventType, function () {\n\t      emitter.removeCurrentListener();\n\t      listener.apply(context, arguments);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Removes all of the registered listeners, including those registered as\n\t   * listener maps.\n\t   *\n\t   * @param {?string} eventType - Optional name of the event whose registered\n\t   *   listeners to remove\n\t   */\n\t\n\t  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\n\t    this._subscriber.removeAllSubscriptions(eventType);\n\t  };\n\t\n\t  /**\n\t   * Provides an API that can be called during an eventing cycle to remove the\n\t   * last listener that was invoked. This allows a developer to provide an event\n\t   * object that can remove the listener (or listener map) during the\n\t   * invocation.\n\t   *\n\t   * If it is called when not inside of an emitting cycle it will throw.\n\t   *\n\t   * @throws {Error} When called not during an eventing cycle\n\t   *\n\t   * @example\n\t   *   var subscription = emitter.addListenerMap({\n\t   *     someEvent: function(data, event) {\n\t   *       console.log(data);\n\t   *       emitter.removeCurrentListener();\n\t   *     }\n\t   *   });\n\t   *\n\t   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n\t   *   emitter.emit('someEvent', 'def'); // does not log anything\n\t   */\n\t\n\t  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\n\t    !!!this._currentSubscription ?  false ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\n\t    this._subscriber.removeSubscription(this._currentSubscription);\n\t  };\n\t\n\t  /**\n\t   * Returns an array of listeners that are currently registered for the given\n\t   * event.\n\t   *\n\t   * @param {string} eventType - Name of the event to query\n\t   * @return {array}\n\t   */\n\t\n\t  BaseEventEmitter.prototype.listeners = function listeners(eventType) /* TODO: Array<EventSubscription> */{\n\t    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n\t    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n\t      return subscription.listener;\n\t    }) : [];\n\t  };\n\t\n\t  /**\n\t   * Emits an event of the given type with the given data. All handlers of that\n\t   * particular type will be notified.\n\t   *\n\t   * @param {string} eventType - Name of the event to emit\n\t   * @param {*} Arbitrary arguments to be passed to each registered listener\n\t   *\n\t   * @example\n\t   *   emitter.addListener('someEvent', function(message) {\n\t   *     console.log(message);\n\t   *   });\n\t   *\n\t   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n\t   */\n\t\n\t  BaseEventEmitter.prototype.emit = function emit(eventType) {\n\t    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n\t    if (subscriptions) {\n\t      var keys = Object.keys(subscriptions);\n\t      for (var ii = 0; ii < keys.length; ii++) {\n\t        var key = keys[ii];\n\t        var subscription = subscriptions[key];\n\t        // The subscription may have been removed during this event loop.\n\t        if (subscription) {\n\t          this._currentSubscription = subscription;\n\t          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n\t        }\n\t      }\n\t      this._currentSubscription = null;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Provides a hook to override how the emitter emits an event to a specific\n\t   * subscription. This allows you to set up logging and error boundaries\n\t   * specific to your environment.\n\t   *\n\t   * @param {EmitterSubscription} subscription\n\t   * @param {string} eventType\n\t   * @param {*} Arbitrary arguments to be passed to each registered listener\n\t   */\n\t\n\t  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n\t    var args = Array.prototype.slice.call(arguments, 2);\n\t    subscription.listener.apply(subscription.context, args);\n\t  };\n\t\n\t  return BaseEventEmitter;\n\t})();\n\t\n\tmodule.exports = BaseEventEmitter;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t * \n\t * @providesModule EmitterSubscription\n\t * @typechecks\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar EventSubscription = __webpack_require__(6);\n\t\n\t/**\n\t * EmitterSubscription represents a subscription with listener and context data.\n\t */\n\t\n\tvar EmitterSubscription = (function (_EventSubscription) {\n\t  _inherits(EmitterSubscription, _EventSubscription);\n\t\n\t  /**\n\t   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls\n\t   *   this subscription\n\t   * @param {function} listener - Function to invoke when the specified event is\n\t   *   emitted\n\t   * @param {*} context - Optional context object to use when invoking the\n\t   *   listener\n\t   */\n\t\n\t  function EmitterSubscription(subscriber, listener, context) {\n\t    _classCallCheck(this, EmitterSubscription);\n\t\n\t    _EventSubscription.call(this, subscriber);\n\t    this.listener = listener;\n\t    this.context = context;\n\t  }\n\t\n\t  return EmitterSubscription;\n\t})(EventSubscription);\n\t\n\tmodule.exports = EmitterSubscription;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t * \n\t * @providesModule EventSubscription\n\t * @typechecks\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * EventSubscription represents a subscription to a particular event. It can\n\t * remove its own subscription.\n\t */\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar EventSubscription = (function () {\n\t\n\t  /**\n\t   * @param {EventSubscriptionVendor} subscriber the subscriber that controls\n\t   *   this subscription.\n\t   */\n\t\n\t  function EventSubscription(subscriber) {\n\t    _classCallCheck(this, EventSubscription);\n\t\n\t    this.subscriber = subscriber;\n\t  }\n\t\n\t  /**\n\t   * Removes this subscription from the subscriber that controls it.\n\t   */\n\t\n\t  EventSubscription.prototype.remove = function remove() {\n\t    this.subscriber.removeSubscription(this);\n\t  };\n\t\n\t  return EventSubscription;\n\t})();\n\t\n\tmodule.exports = EventSubscription;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t * \n\t * @providesModule EventSubscriptionVendor\n\t * @typechecks\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar invariant = __webpack_require__(1);\n\t\n\t/**\n\t * EventSubscriptionVendor stores a set of EventSubscriptions that are\n\t * subscribed to a particular event type.\n\t */\n\t\n\tvar EventSubscriptionVendor = (function () {\n\t  function EventSubscriptionVendor() {\n\t    _classCallCheck(this, EventSubscriptionVendor);\n\t\n\t    this._subscriptionsForType = {};\n\t    this._currentSubscription = null;\n\t  }\n\t\n\t  /**\n\t   * Adds a subscription keyed by an event type.\n\t   *\n\t   * @param {string} eventType\n\t   * @param {EventSubscription} subscription\n\t   */\n\t\n\t  EventSubscriptionVendor.prototype.addSubscription = function addSubscription(eventType, subscription) {\n\t    !(subscription.subscriber === this) ?  false ? invariant(false, 'The subscriber of the subscription is incorrectly set.') : invariant(false) : undefined;\n\t    if (!this._subscriptionsForType[eventType]) {\n\t      this._subscriptionsForType[eventType] = [];\n\t    }\n\t    var key = this._subscriptionsForType[eventType].length;\n\t    this._subscriptionsForType[eventType].push(subscription);\n\t    subscription.eventType = eventType;\n\t    subscription.key = key;\n\t    return subscription;\n\t  };\n\t\n\t  /**\n\t   * Removes a bulk set of the subscriptions.\n\t   *\n\t   * @param {?string} eventType - Optional name of the event type whose\n\t   *   registered supscriptions to remove, if null remove all subscriptions.\n\t   */\n\t\n\t  EventSubscriptionVendor.prototype.removeAllSubscriptions = function removeAllSubscriptions(eventType) {\n\t    if (eventType === undefined) {\n\t      this._subscriptionsForType = {};\n\t    } else {\n\t      delete this._subscriptionsForType[eventType];\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Removes a specific subscription. Instead of calling this function, call\n\t   * `subscription.remove()` directly.\n\t   *\n\t   * @param {object} subscription\n\t   */\n\t\n\t  EventSubscriptionVendor.prototype.removeSubscription = function removeSubscription(subscription) {\n\t    var eventType = subscription.eventType;\n\t    var key = subscription.key;\n\t\n\t    var subscriptionsForType = this._subscriptionsForType[eventType];\n\t    if (subscriptionsForType) {\n\t      delete subscriptionsForType[key];\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Returns the array of subscriptions that are currently registered for the\n\t   * given event type.\n\t   *\n\t   * Note: This array can be potentially sparse as subscriptions are deleted\n\t   * from it when they are removed.\n\t   *\n\t   * TODO: This returns a nullable array. wat?\n\t   *\n\t   * @param {string} eventType\n\t   * @return {?array}\n\t   */\n\t\n\t  EventSubscriptionVendor.prototype.getSubscriptionsForType = function getSubscriptionsForType(eventType) {\n\t    return this._subscriptionsForType[eventType];\n\t  };\n\t\n\t  return EventSubscriptionVendor;\n\t})();\n\t\n\tmodule.exports = EventSubscriptionVendor;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright 2013-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @providesModule emptyFunction\n\t */\n\t\n\t\"use strict\";\n\t\n\tfunction makeEmptyFunction(arg) {\n\t  return function () {\n\t    return arg;\n\t  };\n\t}\n\t\n\t/**\n\t * This function accepts and discards inputs; it has no side effects. This is\n\t * primarily useful idiomatically for overridable function endpoints which\n\t * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n\t */\n\tfunction emptyFunction() {}\n\t\n\temptyFunction.thatReturns = makeEmptyFunction;\n\temptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n\temptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n\temptyFunction.thatReturnsNull = makeEmptyFunction(null);\n\temptyFunction.thatReturnsThis = function () {\n\t  return this;\n\t};\n\temptyFunction.thatReturnsArgument = function (arg) {\n\t  return arg;\n\t};\n\t\n\tmodule.exports = emptyFunction;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** index.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8163dd1ef139ee8d2712\n **/","/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule invariant\n */\n\n\"use strict\";\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function (condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/invariant.js\n ** module id = 1\n ** module chunks = 0 1\n **/","import { EventEmitter } from 'fbemitter';\n\n/**\n * WSClientEvented - WebSocket Client with event emission\n * @author Weblogixx (cs@weblogixx.de)\n *\n * @example let wsClient = new WsClientEvented('ws://localhost:123', 'example-protocol', {\n *   autoOpen: false\n * });\n *\n * Available options:\n * bool autoOpen [default: true] Automatically connect the websocket on initialisation?\n * bool autoReconnect [default: true] Automatically reconnect the websocket if connection is lost?\n * bool debug [default: false] Show debug output?\n * int reconnectInterval [default: 1000] Delay in ms for reconnect tries\n * float reconnectDecay [default 1.5] Factor for reconnects\n * int timeoutInterval [default: 2000] Time in ms to wait for connects\n * string binaryType [default: blob] Binary type for websocket transmission\n * int maxReconnects [default: null] Maximal amount of reconnects. Set to null for inifinite\n * int maxReconnectTimeout [default: 5000] Maximal amount of milliseconds to wait for reconnects\n * int maxSendTries [default: 10] Maximal amount of tries for ws send to fail for the same request\n * function onBeforeWsOpen [default: null] Called before WebSocket connections are established\n * function onWsOpen [default: null] Called when a WebSocket connection becomes ready\n * function onWsMessage [default: null] Called on all WebSocket onMessage events\n * function onWsClose [default: null] Called when a WebSocket connection is closed\n * function onWsError [default: null] Called when a WebSocket connection throws errors\n * function onWsTimeout [default: null] Called when a WebSocket connection times out\n */\nclass WsClientEvented {\n\n  /**\n   * Create a new instance of WsClientEvent\n   * @param {String} url Url to connect to\n   * @param {String|Array} protocols List of protocols [optional]\n   * @param {Object} options Options to pass in [optional]\n   */\n  constructor(url, protocols='', options={}) {\n\n    // Instanciate a new event emitter\n    this.emitter = new EventEmitter();\n\n    this.url = url;\n    this.protocols = protocols && protocols.length > 0 ? protocols : null;\n\n    // How often did the websocket retry to connect?\n    this.reconnectAttempts = 0;\n\n    // Set to true to indicate no reconnect should take place\n    this.forcedClose = false;\n\n    // The websocket instance\n    this.ws = null;\n\n    // List of tries for each send request\n    this.sendTries = {};\n\n    // Default settings\n    this.settings = {\n      autoOpen: true,\n      autoReconnect: true,\n      debug: false,\n      reconnectInterval: 1000,\n      reconnectDecay: 1.5,\n      timeoutInterval: 2000,\n      binaryType: 'blob',\n      maxReconnects: null,\n      maxSendTries: 10,\n      maxReconnectTimeout: 5000,\n      onBeforeWsOpen: null,\n      onWsOpen: null,\n      onWsMessage: null,\n      onWsClose: null,\n      onWsError: null,\n      onWsTimeout: null\n    };\n\n    // Merge settings with defaults\n    for(let key in options) {\n      this.settings[key] = options[key];\n    }\n\n    // Attach all active listeners\n    for(let e of [ 'onBeforeWsOpen', 'onWsOpen', 'onWsMessage', 'onWsClose', 'onWsError', 'onWsTimeout' ]) {\n      if(typeof this.settings[e] === 'function') {\n        this.emitter.addListener(e, (evt) => {\n          this.settings[e](evt, this);\n        });\n      }\n    }\n\n    // Handle websocket requests that come back in the required format.\n    // @todo: Add support for binary\n    this.emitter.addListener('onWsMessage', (e) => {\n      let data = JSON.parse(e.data);\n      let responseType = typeof data;\n\n      if(responseType === 'object' && data.type) {\n        this.emitter.emit(data.type, e, data);\n      }\n    });\n\n    if(this.settings.autoOpen) {\n      this.open();\n    }\n  }\n\n  /**\n   * Output debug information (only if debug setting enabled)\n   * @param  {String} msg Message to output\n   */\n  debug(msg) {\n    if(this.settings.debug) {\n      console.warn(msg);\n    }\n  }\n\n  /**\n   * Add a new event listener\n   * @param {String} evt Name of the event\n   * @param {Function} callback Function to attach\n   * @return {WsClientEvented}\n   */\n  addListener(evt, callback) {\n    this.emitter.addListener(evt, callback);\n    return this;\n  }\n\n  /**\n   * Removes all listeners with a given name\n   * @param  {String} evt\n   * @return {WsClientEvented}\n   */\n  removeListener(evt) {\n    this.emitter.removeAllListeners(evt);\n    return this;\n  }\n\n  /**\n   * Send a new request\n   * @param  {String} event Event to send\n   * @param  {Object|String} payload Data to send as payload [optional]\n   * @return {WsClientEvent}\n   */\n  send(type, payload) {\n\n    // Skip if type is not given\n    if(!type) {\n      throw `Must provide an event type, provided: ${type}`;\n    }\n\n    // Only send if the connection is available.\n    if(!this.ws) {\n      if(this.settings.autoReconnect) {\n        this.open();\n      } else {\n        this.debug(`Tried to send event ${type}, but forced close was set. Please open the connection manually via #open!`);\n        return this;\n      }\n    }\n\n    // Allow to send an empty payload\n    if(!payload) {\n      payload = {};\n    }\n\n    // Add the item to the send try list\n    if(typeof this.sendTries[type] === 'undefined') {\n      this.sendTries[type] = 1;\n    }\n\n    this.debug(`Trying to send event ${type} for the ${this.sendTries[type]} time...`);\n\n    switch(this.ws.readyState) {\n\n      // If the socket is in connecting state, try it again in a couple of ms\n      case WebSocket.CONNECTING:\n\n        // Skip trying to send the request if we reached the maximum\n        if(this.sendTries[type] >= this.settings.maxSendTries) {\n          this.debug(`WS still in connecting state, giving up after ${this.settings.maxSendTries} tries for event ${type}`);\n          return this;\n        }\n\n        this.sendTries[type]++;\n        window.setTimeout(() => {\n          this.send(type, payload);\n        }, 500);\n        break;\n\n      // If the socket is getting closed or is closed, reopen it\n      case WebSocket.CLOSING:\n      case WebSocket.CLOSED:\n\n        // Skip trying to send the request if we reached the maximum\n        if(this.sendTries[type] >= this.settings.maxSendTries) {\n          this.debug(`WS still in closing state, giving up after ${this.settings.maxSendTries} tries for event ${type}`);\n          return this;\n        }\n\n        this.sendTries[type]++;\n        this.open(true);\n        window.setTimeout(() => {\n          this.send(type, payload);\n        }, 500);\n        break;\n\n      // If the websocket is open, just send\n      case WebSocket.OPEN:\n      default:\n\n        this.ws.send(JSON.stringify({\n          type: type,\n          payload: payload\n        }));\n\n        // Request went through, reset the try counter\n        this.sendTries[type] = 1;\n    }\n\n    return this;\n  }\n\n  /**\n   * Open the websocket\n   * @param {Boolean} reconnecting Status of the connection (true if a forced reconnect was done)\n   * @return {WsClientEvent}\n   */\n  open(reconnecting=false) {\n\n    // If the maximal amounts of reconnects is hit, just exit\n    if(this.settings.maxReconnects && this.reconnectAttempts >= this.settings.maxReconnects) {\n      this.debug('Maximal amount of reconnects reached, giving up! Please call #open by yourself to retry.');\n      return this;\n    }\n\n    // Close the websocket if it is already open\n    if(!reconnecting && this.ws) {\n      this.close();\n    }\n\n    this.emitter.emit('onBeforeWsOpen');\n\n    // Automatically disconnect after a given period of time\n    let connectTimeOut = setTimeout(() => {\n      this.debug('WS Connection timed out');\n      this.emitter.emit('onWsTimeout');\n    }, this.settings.timeoutInterval);\n\n    // Create the new websocket instance\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.binaryType = this.settings.binaryType;\n\n    // Add the needed events\n    this.ws.addEventListener('open', (e) => {\n\n      // Clean up the connect timeout after open was fired\n      clearTimeout(connectTimeOut);\n\n      this.emitter.emit('onWsOpen', e, this);\n\n      this.debug(`WS connection successfully opened on attemp#${this.reconnectAttempts}.`);\n\n      // We are connected, so reset the reconnect attempts\n      this.reconnectAttempts = 0;\n\n      // Reset the send queue\n      this.sendTries = {};\n    });\n\n    this.ws.addEventListener('message', (e) => {\n      this.emitter.emit('onWsMessage', e, this);\n    });\n\n    this.ws.addEventListener('close', (e) => {\n\n      clearTimeout(connectTimeOut);\n\n      this.emitter.emit('onWsClose', e, this);\n\n      // Try to reconnect if the close action was not forced via WsClientEvented#close\n      if(!this.forcedClose && this.settings.autoReconnect) {\n\n        // Reconnect the websocket automatically\n        // @credits: https://github.com/joewalnes/reconnecting-websocket/\n        let timeout = this.settings.reconnectInterval * Math.pow(this.settings.reconnectDecay, this.reconnectAttempts);\n        if(timeout > this.settings.maxReconnectTimeout) {\n          timeout = this.settings.maxReconnectTimeout;\n        }\n        this.debug(`Auto reconnect required, trying again in ${timeout} ms...`);\n\n        setTimeout(() => {\n          this.reconnectAttempts++;\n          this.open(true);\n          this.debug('WS connection timed out, trying to reconnect...');\n        }, timeout);\n      } else if(this.forcedClose) {\n        this.forcedClose = false;\n        this.debug('WS forced closing the connection');\n      }\n    });\n\n    this.ws.addEventListener('error', (e) => {\n      this.emitter.emit('onWsError', e, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * Close the websocket if it is open\n   * @param  {Number} code The code to send [optional]\n   * @param  {String} reason The reason for closing [optional]\n   * @return {WsClientEvent}\n   */\n  close(code=1000, reason='') {\n    if(this.ws) {\n      this.forcedClose = true;\n      this.reconnectAttempts = 0;\n      this.sendTries = {};\n      this.ws.close(code, reason);\n      this.ws = null;\n    }\n    return this;\n  }\n}\n\nexport default WsClientEvented;\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/index.js\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar fbemitter = {\n  EventEmitter: require('./lib/BaseEventEmitter')\n};\n\nmodule.exports = fbemitter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/index.js\n ** module id = 3\n ** module chunks = 0 1\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BaseEventEmitter\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar EmitterSubscription = require('./EmitterSubscription');\nvar EventSubscriptionVendor = require('./EventSubscriptionVendor');\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * @class BaseEventEmitter\n * @description\n * An EventEmitter is responsible for managing a set of listeners and publishing\n * events to them when it is told that such events happened. In addition to the\n * data for the given event it also sends a event control object which allows\n * the listeners/handlers to prevent the default behavior of the given event.\n *\n * The emitter is designed to be generic enough to support all the different\n * contexts in which one might want to emit events. It is a simple multicast\n * mechanism on top of which extra functionality can be composed. For example, a\n * more advanced emitter may use an EventHolder and EventFactory.\n */\n\nvar BaseEventEmitter = (function () {\n  /**\n   * @constructor\n   */\n\n  function BaseEventEmitter() {\n    _classCallCheck(this, BaseEventEmitter);\n\n    this._subscriber = new EventSubscriptionVendor();\n    this._currentSubscription = null;\n  }\n\n  /**\n   * Adds a listener to be invoked when events of the specified type are\n   * emitted. An optional calling context may be provided. The data arguments\n   * emitted will be passed to the listener function.\n   *\n   * TODO: Annotate the listener arg's type. This is tricky because listeners\n   *       can be invoked with varargs.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\n    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n  };\n\n  /**\n   * Similar to addListener, except that the listener is removed after it is\n   * invoked once.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke only once when the\n   *   specified event is emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\n    var emitter = this;\n    return this.addListener(eventType, function () {\n      emitter.removeCurrentListener();\n      listener.apply(context, arguments);\n    });\n  };\n\n  /**\n   * Removes all of the registered listeners, including those registered as\n   * listener maps.\n   *\n   * @param {?string} eventType - Optional name of the event whose registered\n   *   listeners to remove\n   */\n\n  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\n    this._subscriber.removeAllSubscriptions(eventType);\n  };\n\n  /**\n   * Provides an API that can be called during an eventing cycle to remove the\n   * last listener that was invoked. This allows a developer to provide an event\n   * object that can remove the listener (or listener map) during the\n   * invocation.\n   *\n   * If it is called when not inside of an emitting cycle it will throw.\n   *\n   * @throws {Error} When called not during an eventing cycle\n   *\n   * @example\n   *   var subscription = emitter.addListenerMap({\n   *     someEvent: function(data, event) {\n   *       console.log(data);\n   *       emitter.removeCurrentListener();\n   *     }\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   *   emitter.emit('someEvent', 'def'); // does not log anything\n   */\n\n  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\n    !!!this._currentSubscription ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\n    this._subscriber.removeSubscription(this._currentSubscription);\n  };\n\n  /**\n   * Returns an array of listeners that are currently registered for the given\n   * event.\n   *\n   * @param {string} eventType - Name of the event to query\n   * @return {array}\n   */\n\n  BaseEventEmitter.prototype.listeners = function listeners(eventType) /* TODO: Array<EventSubscription> */{\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n      return subscription.listener;\n    }) : [];\n  };\n\n  /**\n   * Emits an event of the given type with the given data. All handlers of that\n   * particular type will be notified.\n   *\n   * @param {string} eventType - Name of the event to emit\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   *\n   * @example\n   *   emitter.addListener('someEvent', function(message) {\n   *     console.log(message);\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   */\n\n  BaseEventEmitter.prototype.emit = function emit(eventType) {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    if (subscriptions) {\n      var keys = Object.keys(subscriptions);\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        var subscription = subscriptions[key];\n        // The subscription may have been removed during this event loop.\n        if (subscription) {\n          this._currentSubscription = subscription;\n          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n        }\n      }\n      this._currentSubscription = null;\n    }\n  };\n\n  /**\n   * Provides a hook to override how the emitter emits an event to a specific\n   * subscription. This allows you to set up logging and error boundaries\n   * specific to your environment.\n   *\n   * @param {EmitterSubscription} subscription\n   * @param {string} eventType\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   */\n\n  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n    var args = Array.prototype.slice.call(arguments, 2);\n    subscription.listener.apply(subscription.context, args);\n  };\n\n  return BaseEventEmitter;\n})();\n\nmodule.exports = BaseEventEmitter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/lib/BaseEventEmitter.js\n ** module id = 4\n ** module chunks = 0 1\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n * \n * @providesModule EmitterSubscription\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventSubscription = require('./EventSubscription');\n\n/**\n * EmitterSubscription represents a subscription with listener and context data.\n */\n\nvar EmitterSubscription = (function (_EventSubscription) {\n  _inherits(EmitterSubscription, _EventSubscription);\n\n  /**\n   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls\n   *   this subscription\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  function EmitterSubscription(subscriber, listener, context) {\n    _classCallCheck(this, EmitterSubscription);\n\n    _EventSubscription.call(this, subscriber);\n    this.listener = listener;\n    this.context = context;\n  }\n\n  return EmitterSubscription;\n})(EventSubscription);\n\nmodule.exports = EmitterSubscription;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/lib/EmitterSubscription.js\n ** module id = 5\n ** module chunks = 0 1\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n * \n * @providesModule EventSubscription\n * @typechecks\n */\n\n'use strict';\n\n/**\n * EventSubscription represents a subscription to a particular event. It can\n * remove its own subscription.\n */\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar EventSubscription = (function () {\n\n  /**\n   * @param {EventSubscriptionVendor} subscriber the subscriber that controls\n   *   this subscription.\n   */\n\n  function EventSubscription(subscriber) {\n    _classCallCheck(this, EventSubscription);\n\n    this.subscriber = subscriber;\n  }\n\n  /**\n   * Removes this subscription from the subscriber that controls it.\n   */\n\n  EventSubscription.prototype.remove = function remove() {\n    this.subscriber.removeSubscription(this);\n  };\n\n  return EventSubscription;\n})();\n\nmodule.exports = EventSubscription;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/lib/EventSubscription.js\n ** module id = 6\n ** module chunks = 0 1\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n * \n * @providesModule EventSubscriptionVendor\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * EventSubscriptionVendor stores a set of EventSubscriptions that are\n * subscribed to a particular event type.\n */\n\nvar EventSubscriptionVendor = (function () {\n  function EventSubscriptionVendor() {\n    _classCallCheck(this, EventSubscriptionVendor);\n\n    this._subscriptionsForType = {};\n    this._currentSubscription = null;\n  }\n\n  /**\n   * Adds a subscription keyed by an event type.\n   *\n   * @param {string} eventType\n   * @param {EventSubscription} subscription\n   */\n\n  EventSubscriptionVendor.prototype.addSubscription = function addSubscription(eventType, subscription) {\n    !(subscription.subscriber === this) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The subscriber of the subscription is incorrectly set.') : invariant(false) : undefined;\n    if (!this._subscriptionsForType[eventType]) {\n      this._subscriptionsForType[eventType] = [];\n    }\n    var key = this._subscriptionsForType[eventType].length;\n    this._subscriptionsForType[eventType].push(subscription);\n    subscription.eventType = eventType;\n    subscription.key = key;\n    return subscription;\n  };\n\n  /**\n   * Removes a bulk set of the subscriptions.\n   *\n   * @param {?string} eventType - Optional name of the event type whose\n   *   registered supscriptions to remove, if null remove all subscriptions.\n   */\n\n  EventSubscriptionVendor.prototype.removeAllSubscriptions = function removeAllSubscriptions(eventType) {\n    if (eventType === undefined) {\n      this._subscriptionsForType = {};\n    } else {\n      delete this._subscriptionsForType[eventType];\n    }\n  };\n\n  /**\n   * Removes a specific subscription. Instead of calling this function, call\n   * `subscription.remove()` directly.\n   *\n   * @param {object} subscription\n   */\n\n  EventSubscriptionVendor.prototype.removeSubscription = function removeSubscription(subscription) {\n    var eventType = subscription.eventType;\n    var key = subscription.key;\n\n    var subscriptionsForType = this._subscriptionsForType[eventType];\n    if (subscriptionsForType) {\n      delete subscriptionsForType[key];\n    }\n  };\n\n  /**\n   * Returns the array of subscriptions that are currently registered for the\n   * given event type.\n   *\n   * Note: This array can be potentially sparse as subscriptions are deleted\n   * from it when they are removed.\n   *\n   * TODO: This returns a nullable array. wat?\n   *\n   * @param {string} eventType\n   * @return {?array}\n   */\n\n  EventSubscriptionVendor.prototype.getSubscriptionsForType = function getSubscriptionsForType(eventType) {\n    return this._subscriptionsForType[eventType];\n  };\n\n  return EventSubscriptionVendor;\n})();\n\nmodule.exports = EventSubscriptionVendor;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/lib/EventSubscriptionVendor.js\n ** module id = 7\n ** module chunks = 0 1\n **/","/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule emptyFunction\n */\n\n\"use strict\";\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nfunction emptyFunction() {}\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/emptyFunction.js\n ** module id = 8\n ** module chunks = 0 1\n **/"],"sourceRoot":""}