{"version":3,"sources":["webpack:///index.js","webpack:///webpack/bootstrap fe3eb4ba6aed9d153a98?45e8","webpack:///./~/fbjs/lib/invariant.js?4599","webpack:///./lib/index.js?bdd8","webpack:///./~/fbemitter/index.js?490b","webpack:///./~/fbemitter/lib/BaseEventEmitter.js?e0d9","webpack:///./~/fbemitter/lib/EmitterSubscription.js?44c5","webpack:///./~/fbemitter/lib/EventSubscription.js?3696","webpack:///./~/fbemitter/lib/EventSubscriptionVendor.js?6d33","webpack:///./~/fbjs/lib/emptyFunction.js?2a3b"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","invariant","condition","format","a","b","d","e","f","error","undefined","Error","args","argIndex","replace","name","framesToPop","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","constructor","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","prototype","_fbemitter","WsClientEvented","url","_this","this","protocols","arguments","options","emitter","EventEmitter","reconnectAttempts","forcedClose","ws","sendTries","settings","autoOpen","autoReconnect","debug","forceCloseOnReload","reconnectInterval","reconnectDecay","timeoutInterval","binaryType","payloadItemName","maxReconnects","maxSendTries","maxReconnectTimeout","onBeforeWsOpen","onWsOpen","onWsMessage","onWsClose","onWsError","onWsTimeout","_arr","_loop","_i","addListener","evt","data","JSON","parse","responseType","type","emit","open","window","addEventListener","close","msg","console","warn","callback","removeAllListeners","payload","_this2","readyState","WebSocket","CONNECTING","setTimeout","send","CLOSING","CLOSED","OPEN","stringify","_this3","reconnecting","connectTimeOut","clearTimeout","timeout","Math","pow","code","reason","fbemitter","EmitterSubscription","EventSubscriptionVendor","emptyFunction","BaseEventEmitter","_subscriber","_currentSubscription","eventType","listener","context","addSubscription","once","removeCurrentListener","apply","removeAllSubscriptions","removeSubscription","listeners","subscriptions","getSubscriptionsForType","filter","thatReturnsTrue","map","subscription","keys","ii","__emitToSubscription","concat","Array","slice","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","EventSubscription","_EventSubscription","subscriber","remove","_subscriptionsForType","push","subscriptionsForType","makeEmptyFunction","arg","thatReturns","thatReturnsFalse","thatReturnsNull","thatReturnsThis","thatReturnsArgument"],"mappings":"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","file":"index.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2013-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Use invariant() to assert state which your program assumes to be true.\n\t *\n\t * Provide sprintf-style format (only %s is supported) and arguments\n\t * to provide information about what broke and what you were\n\t * expecting.\n\t *\n\t * The invariant message will be stripped in production, but the invariant\n\t * will remain to ensure logic does not differ in production.\n\t */\n\t\n\tfunction invariant(condition, format, a, b, c, d, e, f) {\n\t  if (false) {\n\t    if (format === undefined) {\n\t      throw new Error('invariant requires an error message argument');\n\t    }\n\t  }\n\t\n\t  if (!condition) {\n\t    var error;\n\t    if (format === undefined) {\n\t      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n\t    } else {\n\t      var args = [a, b, c, d, e, f];\n\t      var argIndex = 0;\n\t      error = new Error(format.replace(/%s/g, function () {\n\t        return args[argIndex++];\n\t      }));\n\t      error.name = 'Invariant Violation';\n\t    }\n\t\n\t    error.framesToPop = 1; // we don't care about invariant's own frame\n\t    throw error;\n\t  }\n\t}\n\t\n\tmodule.exports = invariant;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _fbemitter = __webpack_require__(3);\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * WSClientEvented - WebSocket Client with event emission\n\t * @author Weblogixx (cs@weblogixx.de)\n\t *\n\t * @example let wsClient = new WsClientEvented('ws://localhost:123', 'example-protocol', {\n\t *   autoOpen: false\n\t * });\n\t *\n\t * Available options:\n\t * bool autoOpen [default: true] Automatically connect the websocket on initialisation?\n\t * bool autoReconnect [default: true] Automatically reconnect the websocket if connection is lost?\n\t * bool debug [default: false] Show debug output?\n\t * bool forceCloseOnReload [default: false] Send a forced close on browser reload?\n\t * int reconnectInterval [default: 1000] Delay in ms for reconnect tries\n\t * float reconnectDecay [default 1.5] Factor for reconnects\n\t * int timeoutInterval [default: 2000] Time in ms to wait for connects\n\t * string binaryType [default: blob] Binary type for websocket transmission\n\t * string payloadItemName [default: payload] Send key for send items\n\t * int maxReconnects [default: null] Maximal amount of reconnects. Set to null for inifinite\n\t * int maxReconnectTimeout [default: 5000] Maximal amount of milliseconds to wait for reconnects\n\t * int maxSendTries [default: 10] Maximal amount of tries for ws send to fail for the same request\n\t * function onBeforeWsOpen [default: null] Called before WebSocket connections are established\n\t * function onWsOpen [default: null] Called when a WebSocket connection becomes ready\n\t * function onWsMessage [default: null] Called on all WebSocket onMessage events\n\t * function onWsClose [default: null] Called when a WebSocket connection is closed\n\t * function onWsError [default: null] Called when a WebSocket connection throws errors\n\t * function onWsTimeout [default: null] Called when a WebSocket connection times out\n\t */\n\t\n\tvar WsClientEvented = function () {\n\t\n\t  /**\n\t   * Create a new instance of WsClientEvent\n\t   * @param {String} url Url to connect to\n\t   * @param {String|Array} protocols List of protocols [optional]\n\t   * @param {Object} options Options to pass in [optional]\n\t   */\n\t\n\t  function WsClientEvented(url) {\n\t    var _this = this;\n\t\n\t    var protocols = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\t    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t    _classCallCheck(this, WsClientEvented);\n\t\n\t    // Instanciate a new event emitter\n\t    this.emitter = new _fbemitter.EventEmitter();\n\t\n\t    this.url = url;\n\t    this.protocols = protocols && protocols.length > 0 ? protocols : null;\n\t\n\t    // How often did the websocket retry to connect?\n\t    this.reconnectAttempts = 0;\n\t\n\t    // Set to true to indicate no reconnect should take place\n\t    this.forcedClose = false;\n\t\n\t    // The websocket instance\n\t    this.ws = null;\n\t\n\t    // List of tries for each send request\n\t    this.sendTries = {};\n\t\n\t    // Default settings\n\t    this.settings = {\n\t      autoOpen: true,\n\t      autoReconnect: true,\n\t      debug: false,\n\t      forceCloseOnReload: false,\n\t      reconnectInterval: 1000,\n\t      reconnectDecay: 1.5,\n\t      timeoutInterval: 2000,\n\t      binaryType: 'blob',\n\t      payloadItemName: 'payload',\n\t      maxReconnects: null,\n\t      maxSendTries: 10,\n\t      maxReconnectTimeout: 5000,\n\t      onBeforeWsOpen: null,\n\t      onWsOpen: null,\n\t      onWsMessage: null,\n\t      onWsClose: null,\n\t      onWsError: null,\n\t      onWsTimeout: null\n\t    };\n\t\n\t    // Merge settings with defaults\n\t    for (var key in options) {\n\t      this.settings[key] = options[key];\n\t    }\n\t\n\t    // Attach all active listeners\n\t    var _arr = ['onBeforeWsOpen', 'onWsOpen', 'onWsMessage', 'onWsClose', 'onWsError', 'onWsTimeout'];\n\t\n\t    var _loop = function _loop() {\n\t      var e = _arr[_i];\n\t      if (typeof _this.settings[e] === 'function') {\n\t        _this.emitter.addListener(e, function (evt) {\n\t          _this.settings[e](evt, _this);\n\t        });\n\t      }\n\t    };\n\t\n\t    for (var _i = 0; _i < _arr.length; _i++) {\n\t      _loop();\n\t    }\n\t\n\t    // Handle websocket requests that come back in the required format.\n\t    // @todo: Add support for binary\n\t    this.emitter.addListener('onWsMessage', function (e) {\n\t      var data = JSON.parse(e.data);\n\t      var responseType = typeof data === 'undefined' ? 'undefined' : _typeof(data);\n\t\n\t      if (responseType === 'object' && data.type) {\n\t        _this.emitter.emit(data.type, e, data);\n\t      }\n\t    });\n\t\n\t    if (this.settings.autoOpen) {\n\t      this.open();\n\t    }\n\t\n\t    if (this.settings.forceCloseOnReload) {\n\t      window.addEventListener('beforeunload', function () {\n\t        _this.close();\n\t      });\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Output debug information (only if debug setting enabled)\n\t   * @param  {String} msg Message to output\n\t   */\n\t\n\t\n\t  _createClass(WsClientEvented, [{\n\t    key: 'debug',\n\t    value: function debug(msg) {\n\t      if (this.settings.debug) {\n\t        console.warn(msg);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Add a new event listener\n\t     * @param {String} evt Name of the event\n\t     * @param {Function} callback Function to attach\n\t     * @return {WsClientEvented}\n\t     */\n\t\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(evt, callback) {\n\t      this.emitter.addListener(evt, callback);\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Removes all listeners with a given name\n\t     * @param  {String} evt\n\t     * @return {WsClientEvented}\n\t     */\n\t\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(evt) {\n\t      this.emitter.removeAllListeners(evt);\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Send a new request\n\t     * @param  {String} event Event to send\n\t     * @param  {Object|String} payload Data to send as payload [optional]\n\t     * @return {WsClientEvent}\n\t     */\n\t\n\t  }, {\n\t    key: 'send',\n\t    value: function send(type, payload) {\n\t      var _this2 = this;\n\t\n\t      // Skip if type is not given\n\t      if (!type) {\n\t        throw 'Must provide an event type, provided: ' + type;\n\t      }\n\t\n\t      // Only send if the connection is available.\n\t      if (!this.ws) {\n\t        if (this.settings.autoReconnect) {\n\t          this.open();\n\t        } else {\n\t          this.debug('Tried to send event ' + type + ', but forced close was set. Please open the connection manually via #open!');\n\t          return this;\n\t        }\n\t      }\n\t\n\t      // Allow to send an empty payload\n\t      if (!payload) {\n\t        payload = {};\n\t      }\n\t\n\t      // Add the item to the send try list\n\t      if (typeof this.sendTries[type] === 'undefined') {\n\t        this.sendTries[type] = 1;\n\t      }\n\t\n\t      this.debug('Trying to send event ' + type + ' for the ' + this.sendTries[type] + ' time...');\n\t\n\t      switch (this.ws.readyState) {\n\t\n\t        // If the socket is in connecting state, try it again in a couple of ms\n\t        case WebSocket.CONNECTING:\n\t\n\t          // Skip trying to send the request if we reached the maximum\n\t          if (this.sendTries[type] >= this.settings.maxSendTries) {\n\t            this.debug('WS still in connecting state, giving up after ' + this.settings.maxSendTries + ' tries for event ' + type);\n\t            return this;\n\t          }\n\t\n\t          this.sendTries[type]++;\n\t          window.setTimeout(function () {\n\t            _this2.send(type, payload);\n\t          }, 500);\n\t          break;\n\t\n\t        // If the socket is getting closed or is closed, reopen it\n\t        case WebSocket.CLOSING:\n\t        case WebSocket.CLOSED:\n\t\n\t          // Skip trying to send the request if we reached the maximum\n\t          if (this.sendTries[type] >= this.settings.maxSendTries) {\n\t            this.debug('WS still in closing state, giving up after ' + this.settings.maxSendTries + ' tries for event ' + type);\n\t            return this;\n\t          }\n\t\n\t          this.sendTries[type]++;\n\t          this.open(true);\n\t          window.setTimeout(function () {\n\t            _this2.send(type, payload);\n\t          }, 500);\n\t          break;\n\t\n\t        // If the websocket is open, just send\n\t        case WebSocket.OPEN:\n\t        default:\n\t\n\t          this.ws.send(JSON.stringify(_defineProperty({\n\t            type: type\n\t          }, this.settings.payloadItemName, payload)));\n\t\n\t          // Request went through, reset the try counter\n\t          this.sendTries[type] = 1;\n\t      }\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Open the websocket\n\t     * @param {Boolean} reconnecting Status of the connection (true if a forced reconnect was done)\n\t     * @return {WsClientEvent}\n\t     */\n\t\n\t  }, {\n\t    key: 'open',\n\t    value: function open() {\n\t      var _this3 = this;\n\t\n\t      var reconnecting = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\t\n\t\n\t      // If the maximal amounts of reconnects is hit, just exit\n\t      if (this.settings.maxReconnects && this.reconnectAttempts >= this.settings.maxReconnects) {\n\t        this.debug('Maximal amount of reconnects reached, giving up! Please call #open by yourself to retry.');\n\t        return this;\n\t      }\n\t\n\t      // Close the websocket if it is already open\n\t      if (!reconnecting && this.ws) {\n\t        this.close();\n\t      }\n\t\n\t      this.emitter.emit('onBeforeWsOpen');\n\t\n\t      // Automatically disconnect after a given period of time\n\t      var connectTimeOut = setTimeout(function () {\n\t        _this3.debug('WS Connection timed out');\n\t        _this3.emitter.emit('onWsTimeout');\n\t      }, this.settings.timeoutInterval);\n\t\n\t      // Create the new websocket instance\n\t      this.ws = new WebSocket(this.url, this.protocols);\n\t      this.ws.binaryType = this.settings.binaryType;\n\t\n\t      // Add the needed events\n\t      this.ws.addEventListener('open', function (e) {\n\t\n\t        // Clean up the connect timeout after open was fired\n\t        clearTimeout(connectTimeOut);\n\t\n\t        _this3.emitter.emit('onWsOpen', e, _this3);\n\t\n\t        _this3.debug('WS connection successfully opened on attemp#' + _this3.reconnectAttempts + '.');\n\t\n\t        // We are connected, so reset the reconnect attempts\n\t        _this3.reconnectAttempts = 0;\n\t\n\t        // Reset the send queue\n\t        _this3.sendTries = {};\n\t      });\n\t\n\t      this.ws.addEventListener('message', function (e) {\n\t        _this3.emitter.emit('onWsMessage', e, _this3);\n\t      });\n\t\n\t      this.ws.addEventListener('close', function (e) {\n\t\n\t        clearTimeout(connectTimeOut);\n\t\n\t        _this3.emitter.emit('onWsClose', e, _this3);\n\t\n\t        // Try to reconnect if the close action was not forced via WsClientEvented#close\n\t        if (!_this3.forcedClose && _this3.settings.autoReconnect) {\n\t\n\t          // Reconnect the websocket automatically\n\t          // @credits: https://github.com/joewalnes/reconnecting-websocket/\n\t          var timeout = _this3.settings.reconnectInterval * Math.pow(_this3.settings.reconnectDecay, _this3.reconnectAttempts);\n\t          if (timeout > _this3.settings.maxReconnectTimeout) {\n\t            timeout = _this3.settings.maxReconnectTimeout;\n\t          }\n\t          _this3.debug('Auto reconnect required, trying again in ' + timeout + ' ms...');\n\t\n\t          setTimeout(function () {\n\t            _this3.reconnectAttempts++;\n\t            _this3.open(true);\n\t            _this3.debug('WS connection timed out, trying to reconnect...');\n\t          }, timeout);\n\t        } else if (_this3.forcedClose) {\n\t          _this3.forcedClose = false;\n\t          _this3.debug('WS forced closing the connection');\n\t        }\n\t      });\n\t\n\t      this.ws.addEventListener('error', function (e) {\n\t        _this3.emitter.emit('onWsError', e, _this3);\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Close the websocket if it is open\n\t     * @param  {Number} code The code to send [optional]\n\t     * @param  {String} reason The reason for closing [optional]\n\t     * @return {WsClientEvent}\n\t     */\n\t\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      var code = arguments.length <= 0 || arguments[0] === undefined ? 1000 : arguments[0];\n\t      var reason = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\t\n\t      if (this.ws) {\n\t        this.forcedClose = true;\n\t        this.reconnectAttempts = 0;\n\t        this.sendTries = {};\n\t        this.ws.close(code, reason);\n\t        this.ws = null;\n\t      }\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return WsClientEvented;\n\t}();\n\t\n\texports.default = WsClientEvented;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\tvar fbemitter = {\n\t  EventEmitter: __webpack_require__(4)\n\t};\n\t\n\tmodule.exports = fbemitter;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @providesModule BaseEventEmitter\n\t * @typechecks\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar EmitterSubscription = __webpack_require__(5);\n\tvar EventSubscriptionVendor = __webpack_require__(7);\n\t\n\tvar emptyFunction = __webpack_require__(8);\n\tvar invariant = __webpack_require__(1);\n\t\n\t/**\n\t * @class BaseEventEmitter\n\t * @description\n\t * An EventEmitter is responsible for managing a set of listeners and publishing\n\t * events to them when it is told that such events happened. In addition to the\n\t * data for the given event it also sends a event control object which allows\n\t * the listeners/handlers to prevent the default behavior of the given event.\n\t *\n\t * The emitter is designed to be generic enough to support all the different\n\t * contexts in which one might want to emit events. It is a simple multicast\n\t * mechanism on top of which extra functionality can be composed. For example, a\n\t * more advanced emitter may use an EventHolder and EventFactory.\n\t */\n\t\n\tvar BaseEventEmitter = (function () {\n\t  /**\n\t   * @constructor\n\t   */\n\t\n\t  function BaseEventEmitter() {\n\t    _classCallCheck(this, BaseEventEmitter);\n\t\n\t    this._subscriber = new EventSubscriptionVendor();\n\t    this._currentSubscription = null;\n\t  }\n\t\n\t  /**\n\t   * Adds a listener to be invoked when events of the specified type are\n\t   * emitted. An optional calling context may be provided. The data arguments\n\t   * emitted will be passed to the listener function.\n\t   *\n\t   * TODO: Annotate the listener arg's type. This is tricky because listeners\n\t   *       can be invoked with varargs.\n\t   *\n\t   * @param {string} eventType - Name of the event to listen to\n\t   * @param {function} listener - Function to invoke when the specified event is\n\t   *   emitted\n\t   * @param {*} context - Optional context object to use when invoking the\n\t   *   listener\n\t   */\n\t\n\t  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\n\t    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n\t  };\n\t\n\t  /**\n\t   * Similar to addListener, except that the listener is removed after it is\n\t   * invoked once.\n\t   *\n\t   * @param {string} eventType - Name of the event to listen to\n\t   * @param {function} listener - Function to invoke only once when the\n\t   *   specified event is emitted\n\t   * @param {*} context - Optional context object to use when invoking the\n\t   *   listener\n\t   */\n\t\n\t  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\n\t    var emitter = this;\n\t    return this.addListener(eventType, function () {\n\t      emitter.removeCurrentListener();\n\t      listener.apply(context, arguments);\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Removes all of the registered listeners, including those registered as\n\t   * listener maps.\n\t   *\n\t   * @param {?string} eventType - Optional name of the event whose registered\n\t   *   listeners to remove\n\t   */\n\t\n\t  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\n\t    this._subscriber.removeAllSubscriptions(eventType);\n\t  };\n\t\n\t  /**\n\t   * Provides an API that can be called during an eventing cycle to remove the\n\t   * last listener that was invoked. This allows a developer to provide an event\n\t   * object that can remove the listener (or listener map) during the\n\t   * invocation.\n\t   *\n\t   * If it is called when not inside of an emitting cycle it will throw.\n\t   *\n\t   * @throws {Error} When called not during an eventing cycle\n\t   *\n\t   * @example\n\t   *   var subscription = emitter.addListenerMap({\n\t   *     someEvent: function(data, event) {\n\t   *       console.log(data);\n\t   *       emitter.removeCurrentListener();\n\t   *     }\n\t   *   });\n\t   *\n\t   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n\t   *   emitter.emit('someEvent', 'def'); // does not log anything\n\t   */\n\t\n\t  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\n\t    !!!this._currentSubscription ?  false ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\n\t    this._subscriber.removeSubscription(this._currentSubscription);\n\t  };\n\t\n\t  /**\n\t   * Returns an array of listeners that are currently registered for the given\n\t   * event.\n\t   *\n\t   * @param {string} eventType - Name of the event to query\n\t   * @return {array}\n\t   */\n\t\n\t  BaseEventEmitter.prototype.listeners = function listeners(eventType) /* TODO: Array<EventSubscription> */{\n\t    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n\t    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n\t      return subscription.listener;\n\t    }) : [];\n\t  };\n\t\n\t  /**\n\t   * Emits an event of the given type with the given data. All handlers of that\n\t   * particular type will be notified.\n\t   *\n\t   * @param {string} eventType - Name of the event to emit\n\t   * @param {*} Arbitrary arguments to be passed to each registered listener\n\t   *\n\t   * @example\n\t   *   emitter.addListener('someEvent', function(message) {\n\t   *     console.log(message);\n\t   *   });\n\t   *\n\t   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n\t   */\n\t\n\t  BaseEventEmitter.prototype.emit = function emit(eventType) {\n\t    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n\t    if (subscriptions) {\n\t      var keys = Object.keys(subscriptions);\n\t      for (var ii = 0; ii < keys.length; ii++) {\n\t        var key = keys[ii];\n\t        var subscription = subscriptions[key];\n\t        // The subscription may have been removed during this event loop.\n\t        if (subscription) {\n\t          this._currentSubscription = subscription;\n\t          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n\t        }\n\t      }\n\t      this._currentSubscription = null;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Provides a hook to override how the emitter emits an event to a specific\n\t   * subscription. This allows you to set up logging and error boundaries\n\t   * specific to your environment.\n\t   *\n\t   * @param {EmitterSubscription} subscription\n\t   * @param {string} eventType\n\t   * @param {*} Arbitrary arguments to be passed to each registered listener\n\t   */\n\t\n\t  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n\t    var args = Array.prototype.slice.call(arguments, 2);\n\t    subscription.listener.apply(subscription.context, args);\n\t  };\n\t\n\t  return BaseEventEmitter;\n\t})();\n\t\n\tmodule.exports = BaseEventEmitter;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t * \n\t * @providesModule EmitterSubscription\n\t * @typechecks\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar EventSubscription = __webpack_require__(6);\n\t\n\t/**\n\t * EmitterSubscription represents a subscription with listener and context data.\n\t */\n\t\n\tvar EmitterSubscription = (function (_EventSubscription) {\n\t  _inherits(EmitterSubscription, _EventSubscription);\n\t\n\t  /**\n\t   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls\n\t   *   this subscription\n\t   * @param {function} listener - Function to invoke when the specified event is\n\t   *   emitted\n\t   * @param {*} context - Optional context object to use when invoking the\n\t   *   listener\n\t   */\n\t\n\t  function EmitterSubscription(subscriber, listener, context) {\n\t    _classCallCheck(this, EmitterSubscription);\n\t\n\t    _EventSubscription.call(this, subscriber);\n\t    this.listener = listener;\n\t    this.context = context;\n\t  }\n\t\n\t  return EmitterSubscription;\n\t})(EventSubscription);\n\t\n\tmodule.exports = EmitterSubscription;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @providesModule EventSubscription\n\t * @typechecks\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * EventSubscription represents a subscription to a particular event. It can\n\t * remove its own subscription.\n\t */\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar EventSubscription = (function () {\n\t\n\t  /**\n\t   * @param {EventSubscriptionVendor} subscriber the subscriber that controls\n\t   *   this subscription.\n\t   */\n\t\n\t  function EventSubscription(subscriber) {\n\t    _classCallCheck(this, EventSubscription);\n\t\n\t    this.subscriber = subscriber;\n\t  }\n\t\n\t  /**\n\t   * Removes this subscription from the subscriber that controls it.\n\t   */\n\t\n\t  EventSubscription.prototype.remove = function remove() {\n\t    if (this.subscriber) {\n\t      this.subscriber.removeSubscription(this);\n\t      this.subscriber = null;\n\t    }\n\t  };\n\t\n\t  return EventSubscription;\n\t})();\n\t\n\tmodule.exports = EventSubscription;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t * \n\t * @providesModule EventSubscriptionVendor\n\t * @typechecks\n\t */\n\t\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar invariant = __webpack_require__(1);\n\t\n\t/**\n\t * EventSubscriptionVendor stores a set of EventSubscriptions that are\n\t * subscribed to a particular event type.\n\t */\n\t\n\tvar EventSubscriptionVendor = (function () {\n\t  function EventSubscriptionVendor() {\n\t    _classCallCheck(this, EventSubscriptionVendor);\n\t\n\t    this._subscriptionsForType = {};\n\t    this._currentSubscription = null;\n\t  }\n\t\n\t  /**\n\t   * Adds a subscription keyed by an event type.\n\t   *\n\t   * @param {string} eventType\n\t   * @param {EventSubscription} subscription\n\t   */\n\t\n\t  EventSubscriptionVendor.prototype.addSubscription = function addSubscription(eventType, subscription) {\n\t    !(subscription.subscriber === this) ?  false ? invariant(false, 'The subscriber of the subscription is incorrectly set.') : invariant(false) : undefined;\n\t    if (!this._subscriptionsForType[eventType]) {\n\t      this._subscriptionsForType[eventType] = [];\n\t    }\n\t    var key = this._subscriptionsForType[eventType].length;\n\t    this._subscriptionsForType[eventType].push(subscription);\n\t    subscription.eventType = eventType;\n\t    subscription.key = key;\n\t    return subscription;\n\t  };\n\t\n\t  /**\n\t   * Removes a bulk set of the subscriptions.\n\t   *\n\t   * @param {?string} eventType - Optional name of the event type whose\n\t   *   registered supscriptions to remove, if null remove all subscriptions.\n\t   */\n\t\n\t  EventSubscriptionVendor.prototype.removeAllSubscriptions = function removeAllSubscriptions(eventType) {\n\t    if (eventType === undefined) {\n\t      this._subscriptionsForType = {};\n\t    } else {\n\t      delete this._subscriptionsForType[eventType];\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Removes a specific subscription. Instead of calling this function, call\n\t   * `subscription.remove()` directly.\n\t   *\n\t   * @param {object} subscription\n\t   */\n\t\n\t  EventSubscriptionVendor.prototype.removeSubscription = function removeSubscription(subscription) {\n\t    var eventType = subscription.eventType;\n\t    var key = subscription.key;\n\t\n\t    var subscriptionsForType = this._subscriptionsForType[eventType];\n\t    if (subscriptionsForType) {\n\t      delete subscriptionsForType[key];\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Returns the array of subscriptions that are currently registered for the\n\t   * given event type.\n\t   *\n\t   * Note: This array can be potentially sparse as subscriptions are deleted\n\t   * from it when they are removed.\n\t   *\n\t   * TODO: This returns a nullable array. wat?\n\t   *\n\t   * @param {string} eventType\n\t   * @return {?array}\n\t   */\n\t\n\t  EventSubscriptionVendor.prototype.getSubscriptionsForType = function getSubscriptionsForType(eventType) {\n\t    return this._subscriptionsForType[eventType];\n\t  };\n\t\n\t  return EventSubscriptionVendor;\n\t})();\n\t\n\tmodule.exports = EventSubscriptionVendor;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright 2013-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t */\n\t\n\t\"use strict\";\n\t\n\tfunction makeEmptyFunction(arg) {\n\t  return function () {\n\t    return arg;\n\t  };\n\t}\n\t\n\t/**\n\t * This function accepts and discards inputs; it has no side effects. This is\n\t * primarily useful idiomatically for overridable function endpoints which\n\t * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n\t */\n\tfunction emptyFunction() {}\n\t\n\temptyFunction.thatReturns = makeEmptyFunction;\n\temptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n\temptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n\temptyFunction.thatReturnsNull = makeEmptyFunction(null);\n\temptyFunction.thatReturnsThis = function () {\n\t  return this;\n\t};\n\temptyFunction.thatReturnsArgument = function (arg) {\n\t  return arg;\n\t};\n\t\n\tmodule.exports = emptyFunction;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** index.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap fe3eb4ba6aed9d153a98\n **/","/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/invariant.js\n ** module id = 1\n ** module chunks = 0 1\n **/","import { EventEmitter } from 'fbemitter';\n\n/**\n * WSClientEvented - WebSocket Client with event emission\n * @author Weblogixx (cs@weblogixx.de)\n *\n * @example let wsClient = new WsClientEvented('ws://localhost:123', 'example-protocol', {\n *   autoOpen: false\n * });\n *\n * Available options:\n * bool autoOpen [default: true] Automatically connect the websocket on initialisation?\n * bool autoReconnect [default: true] Automatically reconnect the websocket if connection is lost?\n * bool debug [default: false] Show debug output?\n * bool forceCloseOnReload [default: false] Send a forced close on browser reload?\n * int reconnectInterval [default: 1000] Delay in ms for reconnect tries\n * float reconnectDecay [default 1.5] Factor for reconnects\n * int timeoutInterval [default: 2000] Time in ms to wait for connects\n * string binaryType [default: blob] Binary type for websocket transmission\n * string payloadItemName [default: payload] Send key for send items\n * int maxReconnects [default: null] Maximal amount of reconnects. Set to null for inifinite\n * int maxReconnectTimeout [default: 5000] Maximal amount of milliseconds to wait for reconnects\n * int maxSendTries [default: 10] Maximal amount of tries for ws send to fail for the same request\n * function onBeforeWsOpen [default: null] Called before WebSocket connections are established\n * function onWsOpen [default: null] Called when a WebSocket connection becomes ready\n * function onWsMessage [default: null] Called on all WebSocket onMessage events\n * function onWsClose [default: null] Called when a WebSocket connection is closed\n * function onWsError [default: null] Called when a WebSocket connection throws errors\n * function onWsTimeout [default: null] Called when a WebSocket connection times out\n */\nclass WsClientEvented {\n\n  /**\n   * Create a new instance of WsClientEvent\n   * @param {String} url Url to connect to\n   * @param {String|Array} protocols List of protocols [optional]\n   * @param {Object} options Options to pass in [optional]\n   */\n  constructor(url, protocols='', options={}) {\n\n    // Instanciate a new event emitter\n    this.emitter = new EventEmitter();\n\n    this.url = url;\n    this.protocols = protocols && protocols.length > 0 ? protocols : null;\n\n    // How often did the websocket retry to connect?\n    this.reconnectAttempts = 0;\n\n    // Set to true to indicate no reconnect should take place\n    this.forcedClose = false;\n\n    // The websocket instance\n    this.ws = null;\n\n    // List of tries for each send request\n    this.sendTries = {};\n\n    // Default settings\n    this.settings = {\n      autoOpen: true,\n      autoReconnect: true,\n      debug: false,\n      forceCloseOnReload: false,\n      reconnectInterval: 1000,\n      reconnectDecay: 1.5,\n      timeoutInterval: 2000,\n      binaryType: 'blob',\n      payloadItemName: 'payload',\n      maxReconnects: null,\n      maxSendTries: 10,\n      maxReconnectTimeout: 5000,\n      onBeforeWsOpen: null,\n      onWsOpen: null,\n      onWsMessage: null,\n      onWsClose: null,\n      onWsError: null,\n      onWsTimeout: null\n    };\n\n    // Merge settings with defaults\n    for(let key in options) {\n      this.settings[key] = options[key];\n    }\n\n    // Attach all active listeners\n    for(let e of [ 'onBeforeWsOpen', 'onWsOpen', 'onWsMessage', 'onWsClose', 'onWsError', 'onWsTimeout' ]) {\n      if(typeof this.settings[e] === 'function') {\n        this.emitter.addListener(e, (evt) => {\n          this.settings[e](evt, this);\n        });\n      }\n    }\n\n    // Handle websocket requests that come back in the required format.\n    // @todo: Add support for binary\n    this.emitter.addListener('onWsMessage', (e) => {\n      let data = JSON.parse(e.data);\n      let responseType = typeof data;\n\n      if(responseType === 'object' && data.type) {\n        this.emitter.emit(data.type, e, data);\n      }\n    });\n\n    if(this.settings.autoOpen) {\n      this.open();\n    }\n\n    if(this.settings.forceCloseOnReload) {\n      window.addEventListener('beforeunload', () => {\n        this.close();\n      });\n    }\n  }\n\n  /**\n   * Output debug information (only if debug setting enabled)\n   * @param  {String} msg Message to output\n   */\n  debug(msg) {\n    if(this.settings.debug) {\n      console.warn(msg);\n    }\n  }\n\n  /**\n   * Add a new event listener\n   * @param {String} evt Name of the event\n   * @param {Function} callback Function to attach\n   * @return {WsClientEvented}\n   */\n  addListener(evt, callback) {\n    this.emitter.addListener(evt, callback);\n    return this;\n  }\n\n  /**\n   * Removes all listeners with a given name\n   * @param  {String} evt\n   * @return {WsClientEvented}\n   */\n  removeListener(evt) {\n    this.emitter.removeAllListeners(evt);\n    return this;\n  }\n\n  /**\n   * Send a new request\n   * @param  {String} event Event to send\n   * @param  {Object|String} payload Data to send as payload [optional]\n   * @return {WsClientEvent}\n   */\n  send(type, payload) {\n\n    // Skip if type is not given\n    if(!type) {\n      throw `Must provide an event type, provided: ${type}`;\n    }\n\n    // Only send if the connection is available.\n    if(!this.ws) {\n      if(this.settings.autoReconnect) {\n        this.open();\n      } else {\n        this.debug(`Tried to send event ${type}, but forced close was set. Please open the connection manually via #open!`);\n        return this;\n      }\n    }\n\n    // Allow to send an empty payload\n    if(!payload) {\n      payload = {};\n    }\n\n    // Add the item to the send try list\n    if(typeof this.sendTries[type] === 'undefined') {\n      this.sendTries[type] = 1;\n    }\n\n    this.debug(`Trying to send event ${type} for the ${this.sendTries[type]} time...`);\n\n    switch(this.ws.readyState) {\n\n      // If the socket is in connecting state, try it again in a couple of ms\n      case WebSocket.CONNECTING:\n\n        // Skip trying to send the request if we reached the maximum\n        if(this.sendTries[type] >= this.settings.maxSendTries) {\n          this.debug(`WS still in connecting state, giving up after ${this.settings.maxSendTries} tries for event ${type}`);\n          return this;\n        }\n\n        this.sendTries[type]++;\n        window.setTimeout(() => {\n          this.send(type, payload);\n        }, 500);\n        break;\n\n      // If the socket is getting closed or is closed, reopen it\n      case WebSocket.CLOSING:\n      case WebSocket.CLOSED:\n\n        // Skip trying to send the request if we reached the maximum\n        if(this.sendTries[type] >= this.settings.maxSendTries) {\n          this.debug(`WS still in closing state, giving up after ${this.settings.maxSendTries} tries for event ${type}`);\n          return this;\n        }\n\n        this.sendTries[type]++;\n        this.open(true);\n        window.setTimeout(() => {\n          this.send(type, payload);\n        }, 500);\n        break;\n\n      // If the websocket is open, just send\n      case WebSocket.OPEN:\n      default:\n\n        this.ws.send(JSON.stringify({\n          type: type,\n          [this.settings.payloadItemName]: payload\n        }));\n\n        // Request went through, reset the try counter\n        this.sendTries[type] = 1;\n    }\n\n    return this;\n  }\n\n  /**\n   * Open the websocket\n   * @param {Boolean} reconnecting Status of the connection (true if a forced reconnect was done)\n   * @return {WsClientEvent}\n   */\n  open(reconnecting=false) {\n\n    // If the maximal amounts of reconnects is hit, just exit\n    if(this.settings.maxReconnects && this.reconnectAttempts >= this.settings.maxReconnects) {\n      this.debug('Maximal amount of reconnects reached, giving up! Please call #open by yourself to retry.');\n      return this;\n    }\n\n    // Close the websocket if it is already open\n    if(!reconnecting && this.ws) {\n      this.close();\n    }\n\n    this.emitter.emit('onBeforeWsOpen');\n\n    // Automatically disconnect after a given period of time\n    let connectTimeOut = setTimeout(() => {\n      this.debug('WS Connection timed out');\n      this.emitter.emit('onWsTimeout');\n    }, this.settings.timeoutInterval);\n\n    // Create the new websocket instance\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.binaryType = this.settings.binaryType;\n\n    // Add the needed events\n    this.ws.addEventListener('open', (e) => {\n\n      // Clean up the connect timeout after open was fired\n      clearTimeout(connectTimeOut);\n\n      this.emitter.emit('onWsOpen', e, this);\n\n      this.debug(`WS connection successfully opened on attemp#${this.reconnectAttempts}.`);\n\n      // We are connected, so reset the reconnect attempts\n      this.reconnectAttempts = 0;\n\n      // Reset the send queue\n      this.sendTries = {};\n    });\n\n    this.ws.addEventListener('message', (e) => {\n      this.emitter.emit('onWsMessage', e, this);\n    });\n\n    this.ws.addEventListener('close', (e) => {\n\n      clearTimeout(connectTimeOut);\n\n      this.emitter.emit('onWsClose', e, this);\n\n      // Try to reconnect if the close action was not forced via WsClientEvented#close\n      if(!this.forcedClose && this.settings.autoReconnect) {\n\n        // Reconnect the websocket automatically\n        // @credits: https://github.com/joewalnes/reconnecting-websocket/\n        let timeout = this.settings.reconnectInterval * Math.pow(this.settings.reconnectDecay, this.reconnectAttempts);\n        if(timeout > this.settings.maxReconnectTimeout) {\n          timeout = this.settings.maxReconnectTimeout;\n        }\n        this.debug(`Auto reconnect required, trying again in ${timeout} ms...`);\n\n        setTimeout(() => {\n          this.reconnectAttempts++;\n          this.open(true);\n          this.debug('WS connection timed out, trying to reconnect...');\n        }, timeout);\n      } else if(this.forcedClose) {\n        this.forcedClose = false;\n        this.debug('WS forced closing the connection');\n      }\n    });\n\n    this.ws.addEventListener('error', (e) => {\n      this.emitter.emit('onWsError', e, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * Close the websocket if it is open\n   * @param  {Number} code The code to send [optional]\n   * @param  {String} reason The reason for closing [optional]\n   * @return {WsClientEvent}\n   */\n  close(code=1000, reason='') {\n    if(this.ws) {\n      this.forcedClose = true;\n      this.reconnectAttempts = 0;\n      this.sendTries = {};\n      this.ws.close(code, reason);\n      this.ws = null;\n    }\n    return this;\n  }\n}\n\nexport default WsClientEvented;\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/index.js\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar fbemitter = {\n  EventEmitter: require('./lib/BaseEventEmitter')\n};\n\nmodule.exports = fbemitter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/index.js\n ** module id = 3\n ** module chunks = 0 1\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BaseEventEmitter\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar EmitterSubscription = require('./EmitterSubscription');\nvar EventSubscriptionVendor = require('./EventSubscriptionVendor');\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * @class BaseEventEmitter\n * @description\n * An EventEmitter is responsible for managing a set of listeners and publishing\n * events to them when it is told that such events happened. In addition to the\n * data for the given event it also sends a event control object which allows\n * the listeners/handlers to prevent the default behavior of the given event.\n *\n * The emitter is designed to be generic enough to support all the different\n * contexts in which one might want to emit events. It is a simple multicast\n * mechanism on top of which extra functionality can be composed. For example, a\n * more advanced emitter may use an EventHolder and EventFactory.\n */\n\nvar BaseEventEmitter = (function () {\n  /**\n   * @constructor\n   */\n\n  function BaseEventEmitter() {\n    _classCallCheck(this, BaseEventEmitter);\n\n    this._subscriber = new EventSubscriptionVendor();\n    this._currentSubscription = null;\n  }\n\n  /**\n   * Adds a listener to be invoked when events of the specified type are\n   * emitted. An optional calling context may be provided. The data arguments\n   * emitted will be passed to the listener function.\n   *\n   * TODO: Annotate the listener arg's type. This is tricky because listeners\n   *       can be invoked with varargs.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\n    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n  };\n\n  /**\n   * Similar to addListener, except that the listener is removed after it is\n   * invoked once.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke only once when the\n   *   specified event is emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\n    var emitter = this;\n    return this.addListener(eventType, function () {\n      emitter.removeCurrentListener();\n      listener.apply(context, arguments);\n    });\n  };\n\n  /**\n   * Removes all of the registered listeners, including those registered as\n   * listener maps.\n   *\n   * @param {?string} eventType - Optional name of the event whose registered\n   *   listeners to remove\n   */\n\n  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\n    this._subscriber.removeAllSubscriptions(eventType);\n  };\n\n  /**\n   * Provides an API that can be called during an eventing cycle to remove the\n   * last listener that was invoked. This allows a developer to provide an event\n   * object that can remove the listener (or listener map) during the\n   * invocation.\n   *\n   * If it is called when not inside of an emitting cycle it will throw.\n   *\n   * @throws {Error} When called not during an eventing cycle\n   *\n   * @example\n   *   var subscription = emitter.addListenerMap({\n   *     someEvent: function(data, event) {\n   *       console.log(data);\n   *       emitter.removeCurrentListener();\n   *     }\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   *   emitter.emit('someEvent', 'def'); // does not log anything\n   */\n\n  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\n    !!!this._currentSubscription ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\n    this._subscriber.removeSubscription(this._currentSubscription);\n  };\n\n  /**\n   * Returns an array of listeners that are currently registered for the given\n   * event.\n   *\n   * @param {string} eventType - Name of the event to query\n   * @return {array}\n   */\n\n  BaseEventEmitter.prototype.listeners = function listeners(eventType) /* TODO: Array<EventSubscription> */{\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n      return subscription.listener;\n    }) : [];\n  };\n\n  /**\n   * Emits an event of the given type with the given data. All handlers of that\n   * particular type will be notified.\n   *\n   * @param {string} eventType - Name of the event to emit\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   *\n   * @example\n   *   emitter.addListener('someEvent', function(message) {\n   *     console.log(message);\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   */\n\n  BaseEventEmitter.prototype.emit = function emit(eventType) {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    if (subscriptions) {\n      var keys = Object.keys(subscriptions);\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        var subscription = subscriptions[key];\n        // The subscription may have been removed during this event loop.\n        if (subscription) {\n          this._currentSubscription = subscription;\n          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n        }\n      }\n      this._currentSubscription = null;\n    }\n  };\n\n  /**\n   * Provides a hook to override how the emitter emits an event to a specific\n   * subscription. This allows you to set up logging and error boundaries\n   * specific to your environment.\n   *\n   * @param {EmitterSubscription} subscription\n   * @param {string} eventType\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   */\n\n  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n    var args = Array.prototype.slice.call(arguments, 2);\n    subscription.listener.apply(subscription.context, args);\n  };\n\n  return BaseEventEmitter;\n})();\n\nmodule.exports = BaseEventEmitter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/lib/BaseEventEmitter.js\n ** module id = 4\n ** module chunks = 0 1\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n * \n * @providesModule EmitterSubscription\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventSubscription = require('./EventSubscription');\n\n/**\n * EmitterSubscription represents a subscription with listener and context data.\n */\n\nvar EmitterSubscription = (function (_EventSubscription) {\n  _inherits(EmitterSubscription, _EventSubscription);\n\n  /**\n   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls\n   *   this subscription\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  function EmitterSubscription(subscriber, listener, context) {\n    _classCallCheck(this, EmitterSubscription);\n\n    _EventSubscription.call(this, subscriber);\n    this.listener = listener;\n    this.context = context;\n  }\n\n  return EmitterSubscription;\n})(EventSubscription);\n\nmodule.exports = EmitterSubscription;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/lib/EmitterSubscription.js\n ** module id = 5\n ** module chunks = 0 1\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventSubscription\n * @typechecks\n */\n\n'use strict';\n\n/**\n * EventSubscription represents a subscription to a particular event. It can\n * remove its own subscription.\n */\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar EventSubscription = (function () {\n\n  /**\n   * @param {EventSubscriptionVendor} subscriber the subscriber that controls\n   *   this subscription.\n   */\n\n  function EventSubscription(subscriber) {\n    _classCallCheck(this, EventSubscription);\n\n    this.subscriber = subscriber;\n  }\n\n  /**\n   * Removes this subscription from the subscriber that controls it.\n   */\n\n  EventSubscription.prototype.remove = function remove() {\n    if (this.subscriber) {\n      this.subscriber.removeSubscription(this);\n      this.subscriber = null;\n    }\n  };\n\n  return EventSubscription;\n})();\n\nmodule.exports = EventSubscription;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/lib/EventSubscription.js\n ** module id = 6\n ** module chunks = 0 1\n **/","/**\n * Copyright (c) 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n * \n * @providesModule EventSubscriptionVendor\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * EventSubscriptionVendor stores a set of EventSubscriptions that are\n * subscribed to a particular event type.\n */\n\nvar EventSubscriptionVendor = (function () {\n  function EventSubscriptionVendor() {\n    _classCallCheck(this, EventSubscriptionVendor);\n\n    this._subscriptionsForType = {};\n    this._currentSubscription = null;\n  }\n\n  /**\n   * Adds a subscription keyed by an event type.\n   *\n   * @param {string} eventType\n   * @param {EventSubscription} subscription\n   */\n\n  EventSubscriptionVendor.prototype.addSubscription = function addSubscription(eventType, subscription) {\n    !(subscription.subscriber === this) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The subscriber of the subscription is incorrectly set.') : invariant(false) : undefined;\n    if (!this._subscriptionsForType[eventType]) {\n      this._subscriptionsForType[eventType] = [];\n    }\n    var key = this._subscriptionsForType[eventType].length;\n    this._subscriptionsForType[eventType].push(subscription);\n    subscription.eventType = eventType;\n    subscription.key = key;\n    return subscription;\n  };\n\n  /**\n   * Removes a bulk set of the subscriptions.\n   *\n   * @param {?string} eventType - Optional name of the event type whose\n   *   registered supscriptions to remove, if null remove all subscriptions.\n   */\n\n  EventSubscriptionVendor.prototype.removeAllSubscriptions = function removeAllSubscriptions(eventType) {\n    if (eventType === undefined) {\n      this._subscriptionsForType = {};\n    } else {\n      delete this._subscriptionsForType[eventType];\n    }\n  };\n\n  /**\n   * Removes a specific subscription. Instead of calling this function, call\n   * `subscription.remove()` directly.\n   *\n   * @param {object} subscription\n   */\n\n  EventSubscriptionVendor.prototype.removeSubscription = function removeSubscription(subscription) {\n    var eventType = subscription.eventType;\n    var key = subscription.key;\n\n    var subscriptionsForType = this._subscriptionsForType[eventType];\n    if (subscriptionsForType) {\n      delete subscriptionsForType[key];\n    }\n  };\n\n  /**\n   * Returns the array of subscriptions that are currently registered for the\n   * given event type.\n   *\n   * Note: This array can be potentially sparse as subscriptions are deleted\n   * from it when they are removed.\n   *\n   * TODO: This returns a nullable array. wat?\n   *\n   * @param {string} eventType\n   * @return {?array}\n   */\n\n  EventSubscriptionVendor.prototype.getSubscriptionsForType = function getSubscriptionsForType(eventType) {\n    return this._subscriptionsForType[eventType];\n  };\n\n  return EventSubscriptionVendor;\n})();\n\nmodule.exports = EventSubscriptionVendor;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbemitter/lib/EventSubscriptionVendor.js\n ** module id = 7\n ** module chunks = 0 1\n **/","/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n\"use strict\";\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nfunction emptyFunction() {}\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/emptyFunction.js\n ** module id = 8\n ** module chunks = 0 1\n **/"],"sourceRoot":""}